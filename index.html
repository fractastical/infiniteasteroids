<!DOCTYPE html>
<html>

<head>
  <title>Infinite Space War</title>
  <style>
    body {
      /* margin: 0; */
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: #000;
      color: #fff;
      /* font-family: Arial, sans-serif; */
      flex-direction: column;
    }

    #shipType,
    #technologiesCount {
      position: absolute;
      top: 10px;
      color: white;
      font-size: 14px;
      z-index: 20;
      /* Higher z-index than startScreen */
      font-family: 'Press Start 2P', cursive;
      /* Arcade font */
    }

    .top-right {
      position: absolute;
      top: 10px;
      right: 10px;
    }

    .hidden {
      display: none;
    }

    #game-list {
      display: block;
      width: 100%;
      max-width: 800px;
    }

    .game-item {
      display: flex;
      align-items: center;
      margin-bottom: 20px;
    }

    .game-item img {
      width: 100px;
      height: 100px;
      margin-right: 20px;
    }

    .game-item a {
      color: #800080;
      text-decoration: none;
      font-size: 24px;
    }

    #auth,
    #game-section {
      width: 90%;
      max-width: 600px;
      background: #111;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 20px #00ff00;
      text-align: center;
      margin: 20px;
    }

    h1,
    h2 {
      margin-top: 0;
      padding-top: 20px;
      font-size: 24px;
      color: #800080;
    }

    form {
      margin-bottom: 20px;
    }

    input {
      display: block;
      width: calc(100% - 22px);
      margin: 10px auto;
      padding: 10px;
      font-size: 16px;
      background: #222;
      color: #00ff00;
      border: 1px solid #00ff00;
      border-radius: 5px;
    }

    /* button {
      padding: 10px 20px;
      font-size: 16px;
      background: #00ff00;
      color: #111;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    } */

    button:hover {
      background: #00cc00;
    }

    #shipType {
      left: 10px;
    }

    #technologiesCount {
      right: 10px;
    }


    html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      /* Prevent scrolling */
    }

    canvas {
      border: 1px solid black;
      background-color: black;
    }

    /* Joystick styling */
    #joystick {
      position: absolute;
      bottom: 30px;
      /* Closer to the bottom */
      left: 50%;
      transform: translateX(-50%);
      width: 140px;
      /* Increased width by 40% */
      height: 140px;
      /* Increased height by 40% */
      background-color: rgba(255, 255, 255, 0.2);
      border: 3px solid #fff;
      border-radius: 50%;
      display: none;
      /* Hide by default */
    }

    #volumeScreen {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      height: 200px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      text-align: center;
      padding: 20px;
      border-radius: 10px;
      z-index: 10;
    }

    #volumeScreen input[type="range"] {
      width: 80%;
    }

    #joystick-inner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      /* Adjusted inner circle size */
      height: 60px;
      /* Adjusted inner circle size */
      background-color: white;
      border-radius: 50%;
      border: 2px solid #fff;
      /* Added border for better visibility */
    }

    #joystick .handle {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 70px;
      /* Increased width by 40% */
      height: 70px;
      /* Increased height by 40% */
      background-color: rgba(255, 255, 255, 0.7);
      border: 2px solid #fff;
      border-radius: 50%;
    }

    #marketplace {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #111;
      /* Dark background */
      padding: 20px;
      border: 3px solid #4e15ac;
      /* Red border */
      color: #0f0;
      /* Green text color */
      width: 90%;
      max-width: 400px;
      box-sizing: border-box;
      font-family: 'Press Start 2P', cursive;
      /* Arcade font */

      text-align: center;
    }

    #marketplace h2 {
      font-size: 24px;
      margin-bottom: 20px;
    }

    #marketplace p,
    #marketplace button {
      font-size: 14px;
      margin: 10px 0;
    }

    #marketplace button {
      background-color: #222;
      /* Dark button background */
      color: #0f0;
      /* Green text color */
      border: 2px solid #f00;
      /* Red border */
      padding: 10px;
      width: 100%;
      cursor: pointer;
      font-family: 'Press Start 2P', cursive;
      /* Arcade font */
    }

    #marketplace button:hover {
      background-color: #333;
      /* Slightly lighter background on hover */
    }

    .flashing-arrow {
      position: absolute;
      width: 30px;
      height: 30px;
      border: 2px solid red;
      border-width: 2px 2px 0 0;
      transform: rotate(45deg);
      display: none;
      animation: flash 0.7s infinite;
    }

    @keyframes flash {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0;
      }
    }

    #restartButton {
      position: absolute;
      bottom: 10%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 40px;
      font-size: 15px;
      display: none;
      background-color: white;
      border: 2px solid black;
      border-radius: 5px;
      cursor: pointer;
    }

    #startScreen {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      color: white;
      z-index: 10;
      background-color: #111;
      /* Dark background */
      padding: 20px;
      color: #0f0;
      box-sizing: border-box;
      font-family: 'Press Start 2P', cursive;
      /* Arcade font */
      text-align: center;
      overflow-y: auto;
    }



    #startScreen h2 {
      font-size: 3em;
      /* Increased heading size */
      margin-bottom: 20px;
    }

    #startScreen p {
      font-size: 1.5em;
      /* Increased paragraph size */
      margin-bottom: 20px;
    }

    #startScreen button {
      font-size: 0.9em;
      /* Increased button text size */
      padding: 10px 20px;
    }

    #results {
      display: none;
      position: absolute;
      top: 25%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #111;
      /* Dark background */
      padding: 20px;
      border: 3px solid #f00;
      /* Red border */
      color: #0f0;
      /* Green text color */
      width: 90%;
      max-width: 400px;
      box-sizing: border-box;
      font-family: 'Press Start 2P', cursive;
      /* Arcade font */
      text-align: center;
    }

    #xpBarContainer {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 70%;
      height: 20px;
      background-color: #333;
      border: 2px solid #fff;
      border-radius: 10px;
      overflow: hidden;
      display: none;
    }

    #xpBar {
      width: 0;
      height: 100%;
      background-color: #0f0;
      transition: width 0.5s ease;
      /* Smooth transition effect */
    }

    /* Styles for the level-up modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      max-width: 400px;
      background-color: #111;
      border: 3px solid #4e15ac;
      color: #0f0;
      padding: 20px;
      box-sizing: border-box;
      text-align: center;
      font-family: 'Press Start 2P', cursive;
    }

    .modal-content button {
      background-color: #222;
      color: #0f0;
      border: 2px solid #4e15ac;
      padding: 10px;
      margin: 10px 0;
      width: 100%;
      cursor: pointer;
      font-family: 'Press Start 2P', cursive;
      font-size: 16px;
    }

    .modal-content button:hover {
      background-color: #333;
    }

    .weaponClassIcon {
      display: inline-block;
      width: 36px;
      /* Ensure the size matches the canvas */
      height: 36px;
      /* Ensure the size matches the canvas */
      margin-right: 10px;
      background-size: contain;
      background-repeat: no-repeat;
      background-color: white;
      /* Black background */
      border-radius: 50%;
      /* Make icons circular */
      position: relative;
      /* Relative position to add cooldown indicator */
      z-index: 2;
      /* Ensure icon is on top */
    }

    .cooldown-indicator {
      position: absolute;
      top: -5px;
      /* Adjust to move up */
      left: -5px;
      /* Adjust to move left */
      width: 100%;
      height: 100%;
      border-radius: 50%;
      box-sizing: border-box;
      z-index: 1;
      /* Ensure cooldown indicator is behind the icon */
      pointer-events: none;
      /* Make sure it doesn't block interactions */
    }

    /* Position the bottom icons container */
    .bottom-icons {
      position: fixed;
      bottom: 10px;
      left: 50%;
      /* Center align horizontally */
      transform: translateX(-50%);
      z-index: 1001;
      /* Ensure icons are on top */
      display: flex;
      /* Use flexbox for layout */
      justify-content: center;
      /* Center align the icons */
      /* gap: 10px; /* Add spacing between icons */
      */
    }


    .icon-explosive {
      background-image: url('icons/Explosivelaser.svg');
    }

    .icon-turret {
      background-image: url('icons/Autocannon.svg');
    }

    .icon-drone {
      background-image: url('icons/Laserdrone.svg');
    }

    .icon-bomberdrone {
      background-image: url('icons/Bomberdrone.svg');
    }

    .icon-sonic {
      background-image: url('icons/Sonicray.svg');
    }

    .icon-deathray {
      background-image: url('icons/Deathray.svg');
    }

    .icon-acid {
      background-image: url('icons/Acidbomb.svg');
    }

    .icon-boomerang {
      background-image: url('icons/Boomerang.svg');
    }


    .icon-freeze {
      background-image: url('icons/Freeze.svg');
    }

    .icon-chainlightning {
      background-image: url('icons/chainlightning.png');

    }

    .icon-flamethrower {
      background-image: url('icons/flamethrower.png');
    }

    .icon-explosiverocket {
      background-image: url('icons/explosiverocket.png');
    }


    .icon- {
      background-image: url('icons/Basiclaser.svg');
    }

    .iconContainer {
      position: relative;
      display: inline-block;
      margin-right: 10px;
    }

    .upgradeCount {
      position: absolute;
      top: -10px;
      right: -10px;
      background-color: yellow;
      color: black;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 12px;
      font-weight: bold;
      z-index: 1;
    }

    #achievementsContainer {
      margin-top: 20px;
      /* max-height: 300px; */
      /* Adjust this height as needed */
      overflow-y: auto;
    }

    /* #achievementsContainer {
  margin-top: 20px;
  text-align: left;
  } */

    #achievementsList {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .achievement {
      display: flex;
      align-items: center;
      padding: 5px;
      margin: 5px 0;
      border: 1px solid #ccc;
      border-radius: 5px;
      background-color: #222;
      color: #0f0;

    }

    .achievement span {
      font-size: 12px;
      /* Adjust the font size as needed */
    }


    .achievement img {
      width: 30px;
      height: 30px;
      margin-right: 10px;
    }

    #weaponInfo {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(24, 20, 20, 0.9);
      z-index: 1000;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }

    #weaponInfo h2 {
      font-size: 36px;
      margin-bottom: 20px;
    }

    .weapon {
      display: inline-block;
      margin: 20px;
      text-align: center;
      color: rgb(255, 255, 255);
    }

    .weapon img {
      width: 80px;
      height: 80px;
      display: block;
      margin: 0 auto 10px;
    }

    .weapon p {
      font-size: 14px;
    }

    table {
      width: 100%;
      text-align: center;
      border-collapse: collapse;
    }

    th,
    td {
      padding: 10px;
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">


























































  <!-- #INFINITEGAMES CSS START -->
  <link rel="stylesheet" href="infinite/css/48_leaderboard_20240618013040.css">
  <!-- #INFINITEGAMES CSS END -->
</head>

<body>

  <div id="leftArrow" class="flashing-arrow" style="left: 20px; top: 50%;"></div>
  <div id="rightArrow" class="flashing-arrow" style="right: 20px; top: 50%;"></div>


  <div id="loginPopup" class="modal">
    <div class="modal-content">
      <h2>Login</h2>
      <form id="loginForm">
        <input type="email" id="email" placeholder="Email" required>
        <input type="password" id="password" placeholder="Password" required>
        <button type="submit">Login</button>
      </form>
    </div>
  </div>

  <div class="top-right" id="loginContainer">
    <a href="#" id="login-link">Login</a>
  </div>

  <div class="top-right" id="userInfo" style="display: none;">
    <span id="userNickname"></span> | <a href="#" id="logoutLink">Logout</a>
  </div>



  <div id="xpBarContainer">
    <div id="xpBar"></div>
  </div>

  <!-- version -->
  <div id="shipType">
    Ship type: basic&nbsp;&nbsp; &nbsp; v 0.872.
  </div>


  <div id="technologiesCount">

  </div>
  <!-- 
  <div id="result">

  </div>
 -->
  <div id="levelUpModal" class="modal">
    <div class="modal-content">
      <h2>Level Up!</h2>
      <p>Choose an upgrade:</p>
      <button id="upgrade1" onclick="selectUpgrade(1)"></button>
      <button id="upgrade2" onclick="selectUpgrade(2)"></button>
      <button id="upgrade3" onclick="selectUpgrade(3)"></button>
      <button id="upgrade4" style="display:none" onclick="selectUpgrade(4)"></button>

    </div>
  </div>

  <div id="activeWeaponClassesContainer" class="bottom-icons"></div>

  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <div id="startScreen">
    <div>
      <h2>Welcome to Infinite Asteroids!</h2>
      <!-- <p>Select a Mode to Start:</p> -->
      <table>

        <tr>
          <th>
            <p>Deep Space</p>
          </th>
          <th>
            <p>Meteor Shower</p>
          </th>
          <th>
            <p>Planet</p>
          </th>
        </tr>
        <tr>
          <td>

            <button id="easyButton" onclick="initializeGame(GameModes.EASY)">Easy</button>
            <button id="normalButton" onclick="initializeGame(GameModes.NORMAL)" disabled>Normal</button>
            <button id="hardButton" onclick="initializeGame(GameModes.HARD)" disabled>Hard</button>
            <button id="heroButton" onclick="initializeGame(GameModes.HERO)" disabled>Hero</button>
          </td>
          <td>

            <button id="meteorEasyButton" onclick="initializeGame(GameModes.METEORSHOWEREASY)" disabled>Easy</button>
            <button id="meteorNormalButton" onclick="initializeGame(GameModes.METEORSHOWERNORMAL)"
              disabled>Normal</button>
            <button id="meteorHardButton" onclick="initializeGame(GameModes.METEORSHOWERHARD)" disabled>Hard</button>
            <button id="meteorHeroButton" onclick="initializeGame(GameModes.METEORSHOWERHERO)" disabled>Hero</button>
          </td>
          <td>


            <button id="planetEasyButton" onclick="initializeGame(GameModes.PLANETEASY)" disabled>Easy</button>
            <button id="planetNormalButton" onclick="initializeGame(GameModes.PLANETNORMAL)" disabled>Normal</button>
            <button id="planetHardButton" onclick="initializeGame(GameModes.PLANETHARD)" disabled>Hard</button>
            <button id="planetHeroButton" onclick="initializeGame(GameModes.PLANETHERO)" disabled>Hero</button>
          </td>
        </tr>

      </table>

      <div id="achievementsContainer">

        <h3>Your Achievements</h3>
        <div id="achievementsList"></div>
      </div>


      <!-- <button onclick="initializeGame(GameModes.NORMAL)" ${!modesUnlocked.normal ? 'disabled' : '' }>Normal</button>
      <button onclick="initializeGame(GameModes.HARD)" ${!modesUnlocked.hard ? 'disabled' : '' }>Hard</button> -->
      <!-- <p>Tap lower left for store.</p> -->
      <!-- <p>Tap with two fingers to fire.</p> -->
      <!-- <button onclick="startGame()">Start Game</button> -->
    </div>
  </div>

  <div id="joystick">
    <div id="joystickHandle"></div>

  </div>

  <div id="weaponInfo">
    <h2>Weapon Information</h2>
    <div id="weaponsContainer">
      <!-- Weapon entries will be dynamically added here -->
    </div>
    <button id="closeButton" onclick="toggleWeaponInfo()">Close</button>
  </div>

  <div id="volumeScreen" style="display: none;">
    <h2>Volume Control</h2>
    <input type="range" id="volumeSlider" min="1" max="10" value="5">
    <p>Volume: <span id="volumeValue">5</span></p>
    <button onclick="toggleVolumeScreen()">Close</button>
  </div>

  <div id="marketplace">
    <h2>Marketplace</h2>
    <p>Coins: <span id="coins">0</span></p>
    <button onclick="upgrade('lasers')">Upgrade Lasers (Cost: 100)</button> Level: <span id="laserLevel">1</span><br>
    <button onclick="upgrade('maxbullets')">Upgrade Max Bullets (Cost: 100)</button> Level: <span
      id="maxBulletsLevel">1</span><br>
    <button onclick="upgrade('laserCooldown')">Upgrade Laser Cooldown (Cost: 100)</button> Level: <span
      id="laserCooldownLevel">1</span><br>
    <button onclick="upgrade('explosivelaser')">Explosive Lasers (Cost: 100)</button> Level: <span
      id="explosiveLaserLevel">1</span><br>

    <!-- <button onclick="upgrade('acceleration')">Upgrade Acceleration (Cost: 100)</button> Level: <span id="accelerationLevel">1</span><br> -->
    <button onclick="upgrade('rotationSpeed')">Upgrade Rotation Speed (Cost: 100)</button> Level: <span
      id="rotationSpeedLevel">1</span><br>
    <button onclick="buyDrone()">Buy Drone (Cost: 800)</button><br>
    <button onclick="upgradeDrone('speed')">Upgrade Drone Speed (Cost: 200)</button> Level: <span
      id="droneSpeedLevel">1</span><br>
    <!-- <button onclick="upgradeDrone('laserSpeed')">Upgrade Drone Laser Speed (Cost: 200)</button> Level: <span id="droneLaserSpeedLevel">1</span><br> -->
    <button onclick="upgradeDrone('laserInterval')">Upgrade Drone Firing Frequency (Cost: 200)</button> Level: <span
      id="droneLaserIntervalLevel">1</span><br>
    <button onclick="buyTurret()">Buy Autocannon (Cost: 1000)</button><br>
    <button onclick="upgrade('turretRange')">Upgrade Autocannon Range (Cost: 200)</button> Level: <span
      id="turretRangeLevel">1</span><br>
    <button onclick="upgrade('turretFireRate')">Upgrade Autocannon Fire Rate (Cost: 200)</button> Level: <span
      id="turretFireRateLevel">1</span><br>
    <button onclick="upgrade('turretDamage')">Upgrade Autocannon Damage (Cost: 200)</button> Level: <span
      id="turretDamageLevel">1</span><br>
    <button onclick="exitMarketplace()">Exit Marketplace</button>
  </div>

  <div id="leaderboard-container" style="display:none;">
    <div id="leaderboard">
      <ol id="leaderboard-list"></ol>
    </div>
  </div>

  <audio id="background-music" src="sounds/music_loop.mp3" loop></audio>

  <audio id="meteor-destroy-1" src="sounds/meteor_destroy.mp3"></audio>
  <audio id="meteor-destroy-2" src="sounds/meteor_destroy2.mp3"></audio>
  <audio id="meteor-destroy-3" src="sounds/meteor_destroy3.mp3"></audio>

  <audio id="shot-sound-1" src="sounds/shot1.mp3"></audio>
  <audio id="shot-sound-2" src="sounds/shot2.mp3"></audio>
  <audio id="shot-sound-3" src="sounds/shot3.mp3"></audio>

  <audio id="thruster-sound-1" src="sounds/thruster1.mp3"></audio>
  <audio id="thruster-sound-2" src="sounds/thruster2.mp3"></audio>
  <audio id="thruster-sound-3" src="sounds/thruster3.mp3"></audio>

  <audio id="ship-destroyed" src="sounds/ship_destroyed.mp3"></audio>

  <audio id="alien-entering-sound" src="sounds/alien_entering.mp3"></audio>

  <audio id="gem-collecting-sound" src="sounds/bird_chirp.mp3"></audio>

  <audio id="freeze-sound" src="sounds/freeze.mp3"></audio>
  <audio id="freeze-sound-2" src="sounds/freezew.mp3"></audio>
  <audio id="death-ray-sound" src="sounds/ray.mp3"></audio>
  <audio id="deploy-drone-sound" src="sounds/deploy_drone.mp3"></audio>
  <audio id="acid-bomb-sound" src="sounds/acid_bomb.mp3"></audio>
  <audio id="bomb-lay-sound" src="sounds/lay_bomb.mp3"></audio>


  <button id="restartButton" style="display: none;">Home</button>



  <script>
    // Get the canvas element
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const joystick = document.getElementById('joystick');
    const joystickInner = document.getElementById('joystick-inner');
    const joystickHandle = document.getElementById('joystickHandle');
    const restartButton = document.getElementById('restartButton');
    const backgroundMusic = document.getElementById('background-music');

    let isTouchingJoystick = false;
    let joystickStartX, joystickStartY;
    let isMusicPlaying = true; // Flag to track music state

    const marketplace = document.getElementById('marketplace');
    const coinsDisplay = document.getElementById('coins');

    const laserLevelDisplay = document.getElementById('laserLevel');
    // const accelerationLevelDisplay = document.getElementById('accelerationLevel');
    const maxBulletsLevelDisplay = document.getElementById('maxBulletsLevel');
    const rotationSpeedLevelDisplay = document.getElementById('rotationSpeedLevel');
    const droneSpeedLevelDisplay = document.getElementById('droneSpeedLevel');
    // const droneLaserSpeedLevelDisplay = document.getElementById('droneLaserSpeedLevel');
    const droneLaserIntervalLevelDisplay = document.getElementById('droneLaserIntervalLevel');

    let activeWeaponClasses = []; // Array to store active weapon classes
    let particles = []; // Array to store thruster particles

    let level = 1;
    let xp = 0;
    let xpToNextLevel = 300;

    let acidBomb = {
      cooldown: 300,
      timer: 0,
      duration: 300, // Duration the acid effect lasts (5 seconds at 60 FPS)
      damagePerSecond: 1,
      size: 50,
      activeBombs: [],
      activeAreas: []
    };

    let acidBombUpgrades = {
      duration: 1,
      cooldown: 1,
      size: 1
    };

    let meteorBooster = 0;
    let modeScoreMultiplier = 1;

    const gemImages = {
      common: new Image(),
      rare: new Image(),
      epic: new Image()
    };

    gemImages.common.src = 'icons/common_gem.png';
    gemImages.rare.src = 'icons/rare_gem.png';
    gemImages.epic.src = 'icons/epic_gem.png';


    const GameModes = {
      EASY: 'easy',
      NORMAL: 'normal',
      HARD: 'hard',
      HERO: 'heroic',
      METEORSHOWEREASY: 'meteorshowereasy',
      METEORSHOWERNORMAL: 'meteorshowernormal',
      METEORSHOWERHARD: 'meteorshowerhard',
      METEORSHOWERHERO: 'meteorshowerhero',
      PLANETEASY: 'planeteasy',
      PLANETNORMAL: 'planetnormal',
      PLANETHARD: 'planethard',
      PLANETHERO: 'planethero'
    };

    let currentMode = GameModes.EASY; // Start with Easy mode by default
    let modesUnlocked = {
      easy: true,
      normal: false,
      hard: false,
      hero: false,
      meteoreasy: false,
      meteornormal: false,
      meteorhard: false,
      planeteasy: false,
      planetnormal: false,
      planethard: false,
      planethero: false

    };

    const planet = { x: canvas.width / 2 + 200, y: canvas.height / 2 + 200, radius: 70 };
    let gravityStrength = 0;


    let ship = {
      x: canvas.width / 2,
      y: canvas.height - 50,
      size: 20,
      speed: 0,
      acceleration: 0.15,
      deceleration: 0.96,
      maxSpeed: 5,
      rotation: 0,
      rotationSpeed: 2.5,
      lasers: [],
      velocityX: 0,
      velocityY: 0,
      laserLevel: 2,
      accelerationLevel: 1,
      rotationSpeedLevel: 1,
      maxBulletsLevel: 1,
      explosiveLaserLevel: 0,
      laserCooldown: 30,
      laserTimer: 0,
      laserCooldownLevel: 1,

    };

    let boomerang = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      size: 10,
      speed: 2,
      damage: 1,
      dx: 3,
      dy: 3,
      active: false
    };

    let boomerangUpgrades = {
      speed: 1,
      damage: 1
    };


    let explosiveRocket = {
      cooldown: 120, // Cooldown time in frames (2 seconds at 60 FPS)
      timer: 0, // Current cooldown timer
      speed: 3, // Speed of the rocket
      damage: 10, // Damage dealt by the rocket
      radius: 50, // Explosion radius
      active: false // Flag to track if the rocket is active
    };

    let explosiveRocketUpgrades = {
      damage: 1,
      radius: 1,
      cooldown: 1
    };
    let homingMissile = {
      cooldown: 300,
      timer: 0,
      speed: 2,
      damage: 5,
      activeMissiles: []
    };


    let homingMissileUpgrades = {
      speed: 1,
      damage: 1,
      cooldown: 1
    };

    let freezeEffect = {
      cooldown: 600, // Cooldown period for freeze effect (10 seconds at 60 FPS)
      timer: 0,
      duration: 300, // Duration the freeze effect lasts (5 seconds at 60 FPS)
      active: false,
      remainingDuration: 0
    };


    let freezeEffectUpgrades = {
      duration: 1,
      cooldown: 1
    };


    let damageReport = {
      lasers: 0,
      explosive: 0,
      drones: 0,
      turret: 0,
      sonicBlast: 0,
      bomberDrones: 0,
      deathRay: 0,
      acid: 0,
      freeze: 0,
      boomerang: 0,
      homing: 0,
      explosiverocket: 0,
      flamethrower: 0,
      chainlightning: 0

    };


    let chainLightning = {
      cooldown: 300, // Cooldown time in frames
      timer: 0, // Current cooldown timer
      range: 200, // Range of the chain lightning
      damage: 5, // Damage dealt per hit
      bounces: 2, // Number of bounces
      active: false // Flag to track if the chain lightning is active
    };

    let chainLightningUpgrades = {
      range: 1,
      damage: 1,
      bounces: 1,
      cooldown: 1
    };

    let deathRay = {
      length: 1000,
      width: 50,
      cooldown: 300,
      timer: 0
    };

    let deathRayActive = false;

    let deathRayUpgrades = {
      length: 1,
      width: 1,
      cooldown: 1
    };

    let bomberDrones = [];

    let superWeapons = {
      missile: 0,
      laser: 0,
      bomb: 0
    };

    let drone = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      size: 10,
      speed: 0.0001,
      direction: Math.random() * Math.PI * 2,
      lasers: [],
      laserSpeed: 3,
      laserInterval: 80, // Fire lasers every 120 frames (2 second)
      laserTimer: 0
    };

    let turret = {
      x: 0,
      y: 0,
      size: 10,
      rotationSpeed: 2,
      fireInterval: 120,
      fireTimer: 0,
      range: 400,
      damage: 3,
      color: 'cyan',
      lasers: [] // Initialize the turret's lasers array
    };

    let turretUpgrades = {
      range: 1,
      fireRate: 1,
      damage: 1
    };

    let sonicBlast = {
      cooldown: 300, // Cooldown time in frames (5 seconds at 60 FPS)
      timer: 0, // Current cooldown timer
      range: 120, // Range of the sonic blast
      speed: 2, // Speed of the sonic blast wave
      damage: 1, // Damage dealt by the sonic blast
      waves: [], // Array to store the active sonic blast waves
      rangeLevel: 1,
      damageLevel: 1,
      cooldownLevel: 1

    };

    let flamethrower = {
      cooldown: 10, // Cooldown time in frames
      timer: 0, // Current cooldown timer
      range: 100, // Range of the flamethrower
      damage: 1, // Damage dealt per frame
      active: false, // Flag to track if the flamethrower is active
      damagePerSecond: 1 // Damage dealt per second

    };

    let flamethrowerUpgrades = {
      range: 1,
      damage: 1,
      cooldown: 1
    };




    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      resetShip();
      // Scale the canvas to handle high DPI screens
      // ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      // // Reposition the ship to the center of the canvas
      // ship.x = canvas.width / 2 / window.devicePixelRatio;
      // ship.y = canvas.height - 50 / window.devicePixelRatio;
    };
    resizeCanvas();


    // KEY CONFIG VARs
    let coins = 10000;


    let score = 0;
    let asteroids = [];
    let gameLoop;
    let explosions = [];
    let lives = 3;
    let gameOver = false;
    let invincible = false;
    let invincibilityTimer = 0;


    let wave = 1;
    let waveMessageTimer = 0;
    const waveMessageDuration = 180; // 3 seconds (60 FPS)
    let asteroidsKilled = 0;
    let aliensKilled = 0;
    let drones = [];
    const droneCost = 800;
    let spawnCooldown = 12; // Cooldown time in seconds
    let spawnTimer = spawnCooldown;
    let bonusCoins = 0;

    let droneUpgrades = {
      speed: 1,
      laserSpeed: 1,
      laserInterval: 1
    };


    // Event listeners for keyboard input
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);

    let achievements = [];


    // canvas.addEventListener('touchmove', (e) => {
    //   if (isTouching) {
    //     let touchX = e.touches[0].clientX;
    //     let touchY = e.touches[0].clientY;
    //     let deltaX = touchX - touchStartX;
    //     let deltaY = touchY - touchStartY;

    //     ship.rotation = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
    //     ship.speed = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY) / 15, ship.maxSpeed); // Changed divisor from 10 to 5 for easier control

    //     touchStartX = touchX;
    //     touchStartY = touchY;
    //   }
    // });

    canvas.addEventListener('touchstart', (e) => {

      // lower left corner to access store
      // if (e.touches[0].clientX < canvas.width / 5 && e.touches[0].clientY > canvas.height * 4 / 5) {
      //   pauseGameForMarketplace();
      // }

      if (e.target === canvas && e.touches.length === 2) { // Require two fingers to fire
        ship.lasers.push({ x: ship.x, y: ship.y, rotation: ship.rotation, size: 2 });
      }
    });

    let gameStartTime;
    let gameEndTime;


    // Game loop
    function startGame() {
      gameStartTime = Date.now();

      document.getElementById('technologiesCount').style.display = 'none';
      document.getElementById('startScreen').style.display = 'none';
      document.getElementById('shipType').style.display = 'none';

      startGamingSessionApi();
      createAsteroids();
      invincible = true;
      ship.laserTimer = 0;
      invincibilityTimer = invincibilityDuration;
      gameLoop = setInterval(update, 1000 / 60); // 60 FPS
      if (!toggleOff)
        backgroundMusic.play(); // Play the background music
      isMusicPlaying = true;
    }

    let initialSlowDown = true;

    function update() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      document.getElementById('leaderboard-container').style.display = 'none';


      if (planetMode) {
        drawPlanet();
      }


      // don't let people play with negative lives
      if (lives < 0)
        return;

      if (ship.laserTimer > 0) {
        ship.laserTimer--;
      }

      let angle = ship.rotation * Math.PI / 180;

      if (isMobile()) {
        keys[' '] = true;
      }


      if (keys['ArrowUp'] || keys['w']) {
        if (!toggleOff) backgroundMusic.play(); // Resume the background music (if hasn't started)
        playRandomThrusterSound();

        ship.velocityX += ship.acceleration * Math.sin(angle);
        ship.velocityY -= ship.acceleration * Math.cos(angle);

        // Generate thruster particles
        generateThrusterParticles();
        initialSlowDown = true;

      } else if (keys['ArrowDown'] || keys['s']) {

        if (initialSlowDown) {
          // Apply stronger deceleration if the ship was moving at high speed
          ship.velocityX *= 0.75;
          ship.velocityY *= 0.75;
          if (Math.abs(ship.velocityX) < 2 && Math.abs(ship.velocityY) < 2) {
            initialSlowDown = false; // Disable the stronger deceleration after initial slowdown
          }
        }
        else {

          // Apply strong deceleration if moving forward
          ship.velocityX *= 0.95;
          ship.velocityY *= 0.95;

        }

        applyGravity(ship);

        if (Math.abs(ship.velocityX) < 0.9 && Math.abs(ship.velocityY) < 0.9) {
          if (!toggleOff) backgroundMusic.play(); // Resume the background music (if hasn't started)
          playRandomThrusterSound();

          // Move backwards with higher initial acceleration
          const initialBackwardAcceleration = ship.acceleration * 1.5; // Increased initial backward acceleration
          const backwardSpeed = ship.maxSpeed; // Increased backward speed limit
          ship.velocityX -= initialBackwardAcceleration * Math.sin(angle);
          ship.velocityY += initialBackwardAcceleration * Math.cos(angle);

          // Limit backward speed
          // const currentSpeed = Math.sqrt(ship.velocityX * ship.velocityX + ship.velocityY * ship.velocityY);
          // if (currentSpeed > backwardSpeed) {
          //   ship.velocityX = (ship.velocityX / currentSpeed) * backwardSpeed;
          //   ship.velocityY = (ship.velocityY / currentSpeed) * backwardSpeed;
          // }

          // Generate thruster particles for backward movement
          generateThrusterParticles();
        }
      } else {
        // Apply natural deceleration when no thrust key is pressed
        ship.velocityX *= ship.deceleration;
        ship.velocityY *= ship.deceleration;
      }


      // Update ship position based on velocity
      ship.x += ship.velocityX;
      ship.y += ship.velocityY;

      // Wrap the ship around the screen edges
      if (ship.x < 0) ship.x = canvas.width;
      else if (ship.x > canvas.width) ship.x = 0;
      if (ship.y < 0) ship.y = canvas.height;
      else if (ship.y > canvas.height) ship.y = 0;

      // Handle ship rotation based on key states
      if (keys['ArrowLeft'] || keys['a']) {
        ship.rotation -= ship.rotationSpeed;
      }
      if (keys['ArrowRight'] || keys['d']) {
        ship.rotation += ship.rotationSpeed;
      }

      // Handle shooting based on key state and cooldown
      if (keys[' '] && ship.lasers.length < (ship.maxBulletsLevel * 3) && ship.laserTimer === 0) {
        if (!toggleOff)
          backgroundMusic.play(); // Resume the background music (if hasn't started)
        ship.lasers.push({ x: ship.x, y: ship.y, rotation: ship.rotation, size: ship.laserLevel + 1 });
        ship.laserTimer = ship.laserCooldown;
        playRandomShotSound();
      }

      checkGemCollection();
      updateGems();
      drawGems();

      if (activeWeaponClasses.includes('sonic')) {
        // Update sonic blast cooldown
        if (sonicBlast.timer > 0) {
          sonicBlast.timer--;
        } else {
          activateSonicBlast();
        }
      }

      // Update sonic blast waves
      updateSonicBlast();
      drawSonicBlast();

      if (activeWeaponClasses.includes('deathray')) {
        if (deathRay.timer > 0) {
          deathRay.timer--;
        } else {
          activateDeathRay();
        }
      }

      if (deathRayActive) {
        updateDeathRay();
      }

      if (activeWeaponClasses.includes('explosiverocket')) {
        if (explosiveRocket.timer > 0) {
          explosiveRocket.timer--;
        } else {
          fireExplosiveRocket();
        }
      }
      updateExplosiveRockets();

      if (activeWeaponClasses.includes('acid')) {
        if (acidBomb.timer > 0) {
          acidBomb.timer--;
        } else {
          fireAcidBomb();
        }
      }


      updateAcidBombs();
      updateAcidAreas();
      drawAcidBombs();
      drawAcidAreas();


      if (activeWeaponClasses.includes('freeze')) {
        if (freezeEffect.timer > 0) {
          freezeEffect.timer--;
        } else {
          activateFreezeEffect();
        }
      }


      updateFreezeEffect();

      if (activeWeaponClasses.includes('flamethrower')) {
        if (flamethrower.timer > 0) {
          flamethrower.timer--;
        } else if (keys[' ']) {
          activateFlamethrower();
        }
      }
      updateFlamethrower();
      updateAsteroidFire();

      if (activeWeaponClasses.includes('chainlightning')) {
        if (chainLightning.timer > 0) {
          chainLightning.timer--;
        } else {
          activateChainLightning();
        }
      }



      drawShip();
      drawActiveWeaponClasses();

      updateBoomerang();
      drawBoomerang();

      updateLasers();
      drawLasers();

      if (activeWeaponClasses.includes('homingmissile')) {
        if (homingMissile.timer > 0) {
          homingMissile.timer--;
        } else {
          fireHomingMissile();
        }
      }

      updateHomingMissiles();
      drawHomingMissiles();

      if (turret.bought) {
        updateTurret();
        updateTurretLasers();
        drawTurretLasers();
        drawTurret();
      }

      if (activeWeaponClasses.includes('bomberdrone')) {
        updateBomberDrones();
        drawBomberDrones();
      }

      updateDrones();
      drawDrones();

      updateAsteroids();
      drawAsteroids();

      if (!invincible) {
        for (let i = 0; i < asteroids.length; i++) {
          if (isColliding(ship, asteroids[i])) {
            createExplosion(ship.x, ship.y);
            resetShip();
            lives--;
            playShipDestroyedSound();
            invincible = true;
            invincibilityTimer = invincibilityDuration;
            if (lives === 0) gameOver = true;
          }
        }
      }

      checkLaserCollisions(ship.lasers, true);

      if (turret.bought) {
        checkLaserCollisions(turret.lasers, false);
      }

      if (invincible) {
        invincibilityTimer--;
        if (invincibilityTimer <= 0) invincible = false;
      }

      updateExplosions();
      drawExplosions();

      updateBossAlien();
      drawBossAlien();
      updateBossAlienLaser();
      drawBossAlienLaser();
      updateSuperBossAlien();
      drawSuperBossAlien();
      updateAliens();
      updateAlienLasers();
      drawAliens();
      drawAlienLasers();


      spawnTimer -= 1 / 60; // Assuming 60 FPS

      if (spawnTimer <= 0) {
        wave++;
        if (meteorMode) {

          const side = Math.random() < 0.5 ? 'left' : 'right';
          showArrow(side);

        } else
          createAsteroids();
        spawnAliens(wave); // Spawn aliens based on the current wave
        spawnTimer = spawnCooldown;


      }

      if (gameOver) endGame();
      if (wave > 30) updateAchievementsAtEnd();

      // Update and draw particles
      updateParticles();
      drawParticles();

      drawEdgeOverlay();
      drawLives();
      drawScore();
      if (gameOver) drawDamageReport();


    }

    function drawPlanet() {
      const gradient = ctx.createRadialGradient(
        planet.x,
        planet.y,
        0,
        planet.x,
        planet.y,
        planet.radius
      );
      gradient.addColorStop(0, 'rgba(255, 0, 0, 1)'); // Center color (solid red)
      gradient.addColorStop(1, 'rgba(128, 0, 0, 1)'); // Edge color (darker red)

      ctx.beginPath();
      ctx.arc(planet.x, planet.y, planet.radius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.closePath();
    }

    function drawEdgeOverlay() {
      const overlayWidth = canvas.width * 0.05;
      const overlayHeight = canvas.height * 0.05;

      ctx.fillStyle = 'rgba(0, 0, 0, 0.99)'; // Semi-transparent black color

      // Top overlay
      ctx.fillRect(0, 0, canvas.width, overlayHeight);
      // Bottom overlay
      ctx.fillRect(0, canvas.height - overlayHeight, canvas.width, overlayHeight);
      // Left overlay
      ctx.fillRect(0, 0, overlayWidth, canvas.height);
      // Right overlay
      ctx.fillRect(canvas.width - overlayWidth, 0, overlayWidth, canvas.height);
    }


    // Function to generate thruster particles
    function generateThrusterParticles() {
      const angle = ship.rotation * Math.PI / 180;
      const particle = {
        x: ship.x - Math.sin(angle) * ship.size,
        y: ship.y + Math.cos(angle) * ship.size,
        size: Math.random() * 3 + 1,
        speed: Math.random() * 2 + 1,
        direction: angle + Math.PI,
        life: Math.random() * 30 + 20,
        color: 'rgba(255, 165, 0, 0.8)'
      };
      particles.push(particle);
    }

    // Function to update particles
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        particle.x += Math.sin(particle.direction) * particle.speed;
        particle.y -= Math.cos(particle.direction) * particle.speed;
        particle.life--;
        if (particle.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    // Function to draw particles
    function drawParticles() {
      for (const particle of particles) {
        ctx.fillStyle = particle.color;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }



    function isMobile() {
      return /Mobi|Android/i.test(navigator.userAgent);

    }

    document.addEventListener('DOMContentLoaded', () => {

      // loadAchievements();
      // populateAchievements();
      if (isMobile()) {
        document.getElementById('joystick').style.display = 'block';
        document.getElementById('startScreen').style.display = 'flex';
      } else {
        // startGame();
      }
    });


    function updateSonicBlast() {
      for (let i = 0; i < sonicBlast.waves.length; i++) {
        const wave = sonicBlast.waves[i];
        wave.radius += sonicBlast.speed;

        for (let j = 0; j < asteroids.length; j++) {
          const asteroid = asteroids[j];
          if (isColliding(wave, asteroid) && !wave.hitAsteroids.includes(asteroid.id)) {
            wave.hitAsteroids.push(asteroid.id);
            let actualDamage = Math.min(sonicBlast.damage + damageBooster, asteroid.hitpoints);
            asteroid.hitpoints -= actualDamage;
            damageReport.sonicBlast += actualDamage;

            if (asteroid.hitpoints <= 0) {
              createExplosion(asteroid.x, asteroid.y, asteroid.hitpoints, asteroid.image);
              asteroids.splice(j, 1);
              j--;
            }
          }
        }

        if (wave.radius > sonicBlast.range) {
          sonicBlast.waves.splice(i, 1);
          i--;
        }
      }
    }


    let asteroidDifficultySpeedMultiplier = 1;
    let levelUpXPMultiplier = 1.2;
    let meteorMode = false;
    let planetMode = false;
    let invincibilityDuration = 160; // 3.5 seconds (60 FPS)

    function initializeGame(mode) {
      switch (mode) {
        case GameModes.EASY:
          asteroidDifficultySpeedMultiplier = 0.7;
          levelUpXPMultiplier = 1.07;
          invincibilityDuration = 220;
          break;
        case GameModes.NORMAL:
          asteroidDifficultySpeedMultiplier = 1;
          levelUpXPMultiplier = 1.17;
          modeScoreMultiplier = 1.5;
          break;
        case GameModes.HARD:
          asteroidDifficultySpeedMultiplier = 1.1;
          levelUpXPMultiplier = 1.27;
          modeScoreMultiplier = 2;
          break;
        case GameModes.HERO:
          asteroidDifficultySpeedMultiplier = 1.3;
          levelUpXPMultiplier = 1.35;
          modeScoreMultiplier = 2.5;
          break;
        case GameModes.METEORSHOWEREASY:
          asteroidDifficultySpeedMultiplier = 3.3;
          levelUpXPMultiplier = 1.1;
          modeScoreMultiplier = 1.2;
          meteorMode = true;
          break;
        case GameModes.METEORSHOWERNORMAL:
          asteroidDifficultySpeedMultiplier = 3.3;
          levelUpXPMultiplier = 1.2;
          modeScoreMultiplier = 1.8;
          meteorBooster = 7;
          meteorMode = true;
          break;
        case GameModes.METEORSHOWERHARD:
          asteroidDifficultySpeedMultiplier = 3.4;
          levelUpXPMultiplier = 1.3;
          meteorBooster = 14;
          modeScoreMultiplier = 2.5;
          meteorMode = true;
          break;
        case GameModes.METEORSHOWERHERO:
          asteroidDifficultySpeedMultiplier = 3.5;
          levelUpXPMultiplier = 1.4;
          meteorBooster = 21;
          modeScoreMultiplier = 3.3;
          meteorMode = true;
          break;
        case GameModes.PLANETEASY:
          asteroidDifficultySpeedMultiplier = 1.4;
          levelUpXPMultiplier = 1.1;
          gravityStrength = 60;
          meteorBooster = 7;
          modeScoreMultiplier = 1.6;
          planetMode = true;
          break;
        case GameModes.PLANETNORMAL:
          asteroidDifficultySpeedMultiplier = 1.5;
          levelUpXPMultiplier = 1.2;
          meteorBooster = 14;
          gravityStrength = 90;
          modeScoreMultiplier = 2.4;
          planetMode = true;

          break;
        case GameModes.PLANETHARD:
          asteroidDifficultySpeedMultiplier = 1.7;
          levelUpXPMultiplier = 1.3;
          meteorBooster = 21;
          gravityStrength = 120;
          planetMode = true;
          modeScoreMultiplier = 3.4;
          break;
        case GameModes.PLANETHERO:
          asteroidDifficultySpeedMultiplier = 1.9;
          levelUpXPMultiplier = 1.4;
          meteorBooster = 28;
          gravityStrength = 160;
          planetMode = true;
          modeScoreMultiplier = 4.2;
          break;



      }
      currentMode = mode;

      startGame();
    }

    function drawAcidBombs() {
      ctx.fillStyle = 'green';
      for (let i = 0; i < acidBomb.activeBombs.length; i++) {
        let bomb = acidBomb.activeBombs[i];
        ctx.beginPath();
        ctx.arc(bomb.x, bomb.y, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function fireHomingMissile() {
      if (homingMissile.timer === 0) {
        let missile = {
          x: ship.x,
          y: ship.y,
          target: findNearestAsteroid(),
          speed: homingMissile.speed * homingMissileUpgrades.speed,
          damage: homingMissile.damage * homingMissileUpgrades.damage
        };
        homingMissile.activeMissiles.push(missile);
        homingMissile.timer = homingMissile.cooldown;
      }
    }

    function updateHomingMissiles() {
      for (let i = homingMissile.activeMissiles.length - 1; i >= 0; i--) {
        let missile = homingMissile.activeMissiles[i];
        if (missile.target) {
          let dx = missile.target.x - missile.x;
          let dy = missile.target.y - missile.y;
          let distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < missile.target.size) {
            createExplosion(missile.target.x, missile.target.y);
            let index = asteroids.indexOf(missile.target);
            // let actualDamage = asteroids[index].hitpoints;
            damageReport.homing += 5;
            increaseXP(5 * 20);
            asteroids.splice(index, 1);
            homingMissile.activeMissiles.splice(i, 1);
            continue;
          }

          let angle = Math.atan2(dy, dx);
          missile.x += missile.speed * Math.cos(angle);
          missile.y += missile.speed * Math.sin(angle);
        } else {
          homingMissile.activeMissiles.splice(i, 1);
        }
      }
    }

    function drawHomingMissiles() {
      for (let i = 0; i < homingMissile.activeMissiles.length; i++) {
        let missile = homingMissile.activeMissiles[i];
        ctx.save();
        ctx.translate(missile.x, missile.y);

        // Calculate the rotation angle based on the missile's direction
        let angle = Math.atan2(missile.dy, missile.dx);
        ctx.rotate(angle);

        // Draw the homing missile image
        ctx.drawImage(droneImages.nanoDrone, -5, -5, 10, 10);
        ctx.restore();
      }
    }

    function handleLaserAlienCollision(laser, alien) {
      createExplosion(alien.x, alien.y);
      aliens.splice(aliens.indexOf(alien), 1);
      ship.lasers.splice(ship.lasers.indexOf(laser), 1);
      increaseXP(300);
      aliensKilled++;
      score += 300; // Adjust the score as needed
    }

    let droppedGems = [];

    function drawGems() {
      for (let i = 0; i < droppedGems.length; i++) {
        let gem = droppedGems[i];
        ctx.drawImage(gemImages[gem.type], gem.x - gem.size / 2, gem.y - gem.size / 2, gem.size, gem.size);
      }
    }

    function checkGemCollection() {
      for (let i = droppedGems.length - 1; i >= 0; i--) {
        let gem = droppedGems[i];
        if (isColliding(ship, gem)) {
          // Determine the XP boost based on the gem type
          let xpBoost;
          playGemCollectingSound();
          switch (gem.type) {
            case 'common':
              xpBoost = xpToNextLevel * 0.2; // 10% of XP to next level
              break;
            case 'rare':
              xpBoost = xpToNextLevel * 0.5; // 25% of XP to next level
              break;
            case 'epic':
              xpBoost = xpToNextLevel * 0.95; // 50% of XP to next level
              break;
          }

          // Increase the XP and check for level up
          xp += xpBoost;
          updateXPBar();
          if (xp >= xpToNextLevel) {
            levelUp();
          }

          // Remove the collected gem
          droppedGems.splice(i, 1);
        }
      }
    }

    function updateGems() {
      for (let i = 0; i < droppedGems.length; i++) {
        let gem = droppedGems[i];
        gem.x += gem.dx;
        gem.y += gem.dy;

        // Remove gems that go off-screen
        if (gem.x < 0 || gem.x > canvas.width || gem.y < 0 || gem.y > canvas.height) {
          droppedGems.splice(i, 1);
          i--;
        }
      }
    }




    // Function to handle laser collisions
    function checkLaserCollisions(lasers, isShip) {
      for (let i = lasers.length - 1; i >= 0; i--) {
        let laser = lasers[i];

        for (let j = aliens.length - 1; j >= 0; j--) {
          const alien = aliens[j];
          if (isColliding(laser, alien)) {
            handleLaserAlienCollision(laser, alien);
            break;
          }
        }

        if (alien && isColliding(laser, alien)) {

          let damage = isShip ? ship.laserLevel : 1; // Damage based on laserLevel for ship lasers
          let actualDamage = Math.min(damage + damageBooster, alien.hitpoints); // Ensure we don't overkill the asteroid
          alien.hitpoints -= actualDamage;

          createExplosion(alien.x, alien.y);

          if (alien.hitpoints <= 0) {
            createExplosion(alien.x, alien.y, 15);
            alien = null; // Destroy alien
            aliensKilled++;
            increaseXP(30 * 20);
            score += 1000;
          }
          lasers.splice(i, 1); // Remove laser
          break;
        }


        if (superbossAlien && isColliding(laser, superbossAlien)) {

          let damage = isShip ? ship.laserLevel : 1; // Damage based on laserLevel for ship lasers
          let actualDamage = Math.min(damage + damageBooster, superbossAlien.hitpoints); // Ensure we don't overkill the asteroid
          superbossAlien.hitpoints -= actualDamage;

          createExplosion(superbossAlien.x, superbossAlien.y);

          if (superbossAlien.hitpoints <= 0) {
            createExplosion(superbossAlien.x, superbossAlien.y, 15);
            superbossAlien = null; // Destroy alien
            aliensKilled++;
            increaseXP(30 * 20);
            score += 100000;
          }
          lasers.splice(i, 1); // Remove laser
          break;
        }


        for (let j = asteroids.length - 1; j >= 0; j--) {
          let asteroid = asteroids[j];
          if (isColliding(laser, asteroid)) {
            let damage = isShip ? ship.laserLevel : 1; // Damage based on laserLevel for ship lasers

            let actualDamage = Math.min(damage + damageBooster, asteroid.hitpoints); // Ensure we don't overkill the asteroid
            asteroid.hitpoints -= actualDamage;

            if (asteroid.hitpoints <= 0) {
              if (asteroid.isLarge) {
                createSmallerAsteroids(asteroid.x, asteroid.y, asteroid.size, asteroid.speed, 1); // Split into smaller asteroids
              }
              createExplosion(asteroid.x, asteroid.y, asteroid.hitpoints, asteroid.image);
              asteroids.splice(j, 1);
              asteroidsKilled++;
              let gemRarity;
              if (asteroid.initialHitpoints > 30) {
                gemRarity = 'epic';
              } else if (asteroid.initialHitpoints > 15) {
                gemRarity = 'rare';
              } else if (asteroid.initialHitpoints > 4) {
                gemRarity = 'common';
              }

              if (gemRarity && Math.random() < 0.1) {
                console.log("gem");

                droppedGems.push({
                  x: asteroid.x,
                  y: asteroid.y,
                  size: 10,
                  type: gemRarity,
                  dx: asteroid.dx / 5, // Gem's velocity in the x-direction
                  dy: asteroid.dy / 5  // Gem's velocity in the y-direction

                });
              }



            } else {
              // Lighten the color slightly
              let colorValue = Math.max(40, 30 + (asteroid.hitpoints * 3)); // Adjust color value
              asteroid.color = `rgb(${colorValue}, ${colorValue}, ${colorValue})`;
            }

            lasers.splice(i, 1);
            score += actualDamage * 50; // Increase score based on actual damage

            playRandomMeteorDestroySound();
            coins += actualDamage * 20; // Add coins based on actual damage
            increaseXP(actualDamage * 20); // Increase XP based on actual damage

            // Track damage
            if (isShip) {
              damageReport.lasers += actualDamage;

              // Handle explosive laser effect
              if (ship.explosiveLaserLevel > 0) {
                createExplosion(laser.x, laser.y, 0);
                let areaDamage = createAreaDamage(laser.x, laser.y, ship.explosiveLaserLevel * 15, ship.laserLevel); // Increase radius based on explosiveLaserLevel and damage based on laserLevel
                damageReport.explosive += areaDamage;
              }
            } else {
              damageReport.turret += actualDamage;
            }

            break;
          }
        }
      }
    }




    // Function to buy drones
    function buyDrone() {
      // if (coins >= droneCost) {
      //   coins -= droneCost;
      let drone = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        size: 10,
        damage: 1,
        speed: 0.5 * droneUpgrades.speed,
        direction: Math.random() * Math.PI * 2,
        lasers: [],
        image: droneImages.regularDrone,
        laserSpeed: 2 * droneUpgrades.laserSpeed,
        laserInterval: 80 / droneUpgrades.laserInterval, // Fire lasers more frequently as the interval increases
        laserTimer: 0
      };
      drones.push(drone);
      playDeployDroneSound();
      // updateCoinsDisplay();
      // }
    }

    function buyBomberDrone() {
      let bomberDrone = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        size: 12,
        speed: 0.5 * bomberDroneUpgrades.speed,
        direction: Math.random() * Math.PI * 2,
        image: droneImages.bomberDrone,
        bombs: [],
        bombInterval: 120,
        bombTimer: 0
      };
      bomberDrones.push(bomberDrone);
      playDeployDroneSound();

    }


    function buyTurret() {
      if (!turret.bought) {
        // coins -= 1000;
        turret.bought = true;
        turret.x = ship.x;
        turret.y = ship.y;
        // updateCoinsDisplay();
      }
    }


    let doubleTurret = false;
    let tripleTurret = false;

    function updateTurret() {
      let nearestAsteroid = findNearestAsteroidInRange();
      if (nearestAsteroid) {
        let dx = nearestAsteroid.x - turret.x;
        let dy = nearestAsteroid.y - turret.y;
        let angle = Math.atan2(dy, dx);
        turret.rotation = angle;

        turret.fireTimer++;
        if (turret.fireTimer >= turret.fireInterval) {
          turret.fireTimer = 0;
          let laser = {
            x: turret.x,
            y: turret.y,
            rotation: turret.rotation,
            size: 2,
            color: 'blue' // Set the turret laser color to blue
          };
          turret.lasers.push(laser);
          if (doubleTurret) {
            let laser = {
              x: turret.x + 3,
              y: turret.y - 1,
              rotation: turret.rotation,
              size: 2,
              color: 'blue' // Set the turret laser color to blue
            };
            turret.lasers.push(laser);

          }
          if (tripleTurret) {
            let laser = {
              x: turret.x - 3,
              y: turret.y - 1,
              rotation: turret.rotation,
              size: 2,
              color: 'blue' // Set the turret laser color to blue
            };
            turret.lasers.push(laser);

          }
        }
      }

      turret.x = ship.x;
      turret.y = ship.y;
    }

    function updateTurretLasers() {
      for (let i = turret.lasers.length - 1; i >= 0; i--) {
        let laser = turret.lasers[i];
        laser.x += Math.cos(laser.rotation) * 2;
        laser.y += Math.sin(laser.rotation) * 2;
        if (laser.x < 0 || laser.x > canvas.width || laser.y < 0 || laser.y > canvas.height) {
          turret.lasers.splice(i, 1);
        }
      }
    }


    function drawTurretLasers() {
      // console.log(turret.lasers.length);

      for (let i = 0; i < turret.lasers.length; i++) {
        // console.log('blue');
        let laser = turret.lasers[i];
        ctx.fillStyle = turret.color;
        // ctx.fillStyle = 'cyan';
        // console.log(laser.x + " , " + laser.y);
        ctx.fillRect(laser.x - laser.size * 2, laser.y - laser.size * 2, laser.size * 2, laser.size * 2);
      }
    }


    function updateBoomerang() {
      if (!boomerang.active) return;

      boomerang.x += boomerang.dx * boomerang.speed;
      boomerang.y += boomerang.dy * boomerang.speed;

      // Calculate the rotation angle based on the boomerang's velocity
      boomerang.angle = Math.atan2(boomerang.dy, boomerang.dx);

      // Bounce off the edges of the screen
      if (boomerang.x < 0 || boomerang.x > canvas.width) {
        boomerang.dx = -boomerang.dx;
      }
      if (boomerang.y < 0 || boomerang.y > canvas.height) {
        boomerang.dy = -boomerang.dy;
      }

      // Check collision with asteroids
      for (let i = 0; i < asteroids.length; i++) {
        let asteroid = asteroids[i];
        if (isColliding(boomerang, asteroid)) {
          let actualDamage = Math.min(boomerang.damage + damageBooster, asteroid.hitpoints);
          asteroid.hitpoints -= actualDamage;
          damageReport.boomerang += actualDamage;

          if (asteroid.hitpoints <= 0) {
            createExplosion(asteroid.x, asteroid.y, asteroid.hitpoints);
            asteroids.splice(i, 1);
            score += actualDamage * 50;
            coins += actualDamage * 20;
            increaseXP(actualDamage * 20);
          }
        }
      }
    }

    const boomerangImage = new Image();
    boomerangImage.src = 'icons/Boomeranggold.png';

    function drawBoomerang() {
      if (!boomerang.active) return;

      // ctx.fillStyle = 'orange';
      // ctx.beginPath();
      // ctx.arc(boomerang.x, boomerang.y, boomerang.size, 0, Math.PI * 2);
      // ctx.closePath();
      // ctx.fill();

      ctx.save();
      ctx.translate(boomerang.x, boomerang.y);
      ctx.rotate(boomerang.angle);
      ctx.drawImage(boomerangImage, -boomerang.size / 2, -boomerang.size / 2, boomerang.size * 3, boomerang.size * 3);
      ctx.restore();

    }

    function activateBoomerang() {
      boomerang.active = true;
      boomerang.x = canvas.width / 2;
      boomerang.y = canvas.height / 2;
      boomerang.dx = (Math.random() * 2.2 - 1) * boomerang.speed;
      boomerang.dy = (Math.random() * 2.2 - 1) * boomerang.speed;
    }

    // function drawLasers() {
    //   ctx.fillStyle = 'red';
    //   for (let i = 0; i < ship.lasers.length; i++) {
    //     ctx.fillRect(ship.lasers[i].x - 1, ship.lasers[i].y - 1, ship.laserLevel + 3, ship.laserLevel + 3); // Drawing lasers as small squares for better collision detection
    //   }
    // }

    function drawTurret() {
      ctx.save();
      ctx.translate(turret.x, turret.y);
      ctx.rotate(turret.rotation * Math.PI / 180);
      ctx.fillStyle = 'cyan';
      // ctx.arc(0, 0, 10, 0, Math.PI * 2);
      // ctx.strokeStyle = 'cyan';
      // ctx.stroke();

      ctx.fillRect(-turret.size / 2, -turret.size / 2, turret.size + 2, turret.size);
      ctx.restore();

      ctx.beginPath();

    }

    function findNearestAsteroid() {
      let nearestAsteroid = null;
      let nearestDistance = Infinity;
      for (let i = 0; i < asteroids.length; i++) {
        let dx = ship.x - asteroids[i].x;
        let dy = ship.y - asteroids[i].y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < nearestDistance) {
          nearestAsteroid = asteroids[i];
          nearestDistance = distance;
        }
      }
      return nearestAsteroid;
    }


    function findNearestAsteroidInRange() {
      let nearestAsteroid = null;
      let nearestDistance = Infinity;
      for (let i = 0; i < asteroids.length; i++) {
        let dx = turret.x - asteroids[i].x;
        let dy = turret.y - asteroids[i].y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < nearestDistance && distance <= turret.range) {
          nearestAsteroid = asteroids[i];
          nearestDistance = distance;
        }
      }
      return nearestAsteroid;
    }


    function drawSonicBlast() {
      ctx.strokeStyle = 'blue';
      ctx.lineWidth = 1;
      for (let i = 0; i < sonicBlast.waves.length; i++) {
        const wave = sonicBlast.waves[i];
        ctx.beginPath();
        ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
        ctx.stroke();
      }
    }


    function selectUpgrade(choice) {
      const upgrades = window.levelUpgrades;
      applyUpgrade(upgrades[choice - 1]);
      document.getElementById('levelUpModal').style.display = 'none';

      // Resume the game
      gameLoop = setInterval(update, 1000 / 60); // 60 FPS
    }


    function upgradeDrone(attribute) {
      const cost = 200;
      // if (coins >= cost) {
      //   coins -= cost;
      droneUpgrades[attribute]++;

      // Update existing drones with new upgrade levels
      drones.forEach(drone => {
        switch (attribute) {
          case 'speed':
            drone.speed = 2 * droneUpgrades.speed;
            break;
          case 'laserSpeed':
            drone.laserSpeed = 5 * droneUpgrades.laserSpeed;
            break;
          case 'laserInterval':
            drone.laserInterval = 120 / droneUpgrades.laserInterval;
            break;
        }
      });
      // updateCoinsDisplay();
      // updateMarketplaceDisplay();

    }

    function applyGravity(object) {
      const dx = planet.x - object.x;
      const dy = planet.y - object.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      let force = gravityStrength / (distance * distance); // Inverse-square law
      if (force > 0.9) {
        console.log(force);
        force = 0.9;
      }

      object.dx += force * dx / distance;
      object.dy += force * dy / distance;
    }

    // Update all drones
    function updateDrones() {
      drones.forEach(drone => {
        const dx = ship.x - drone.x;
        const dy = ship.y - drone.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > 250) { // If the drone is too far from the ship
          const angleToShip = Math.atan2(dy, dx);
          drone.direction = angleToShip; // Change direction towards the ship
        }

        drone.x += Math.cos(drone.direction) * drone.speed;
        drone.y += Math.sin(drone.direction) * drone.speed;

        if (drone.x < 0) drone.x = canvas.width;
        else if (drone.x > canvas.width) drone.x = 0;
        if (drone.y < 0) drone.y = canvas.height;
        else if (drone.y > canvas.height) drone.y = 0;

        for (let i = drone.lasers.length - 1; i >= 0; i--) {
          let laser = drone.lasers[i];
          laser.x += Math.cos(laser.direction) * drone.laserSpeed;
          laser.y += Math.sin(laser.direction) * drone.laserSpeed;

          if (laser.x < 0 || laser.x > canvas.width || laser.y < 0 || laser.y > canvas.height) {
            drone.lasers.splice(i, 1);
          }
        }

        drone.laserTimer++;
        if (drone.laserTimer >= drone.laserInterval) {
          drone.laserTimer = 0;
          let laser = {
            x: drone.x,
            y: drone.y,
            direction: Math.random() * Math.PI * 2,
            size: 2
          };
          drone.lasers.push(laser);
        }

        // Track damage for drone lasers
        drone.lasers.forEach(laser => {
          for (let j = asteroids.length - 1; j >= 0; j--) {
            let asteroid = asteroids[j];
            if (isColliding(laser, asteroid)) {
              let actualDamage = Math.min(drone.damage + damageBooster, asteroid.hitpoints);
              asteroid.hitpoints -= actualDamage;
              damageReport.drones += actualDamage;
            }
          }
        });

        checkLaserCollisions(drone.lasers, false);
      });
    }


    function updateBomberDrones() {
      bomberDrones.forEach(drone => {
        const dx = ship.x - drone.x;
        const dy = ship.y - drone.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > 200) {
          const angleToShip = Math.atan2(dy, dx);
          const deviationAngle = (Math.random() - 0.5) * (Math.PI / 3);
          drone.direction = angleToShip + deviationAngle;

        }

        drone.x += Math.cos(drone.direction) * drone.speed;
        drone.y += Math.sin(drone.direction) * drone.speed;

        if (drone.x < 0) drone.x = canvas.width;
        else if (drone.x > canvas.width) drone.x = 0;
        if (drone.y < 0) drone.y = canvas.height;
        else if (drone.y > canvas.height) drone.y = 0;

        drone.bombTimer++;
        if (drone.bombTimer >= drone.bombInterval) {
          drone.bombTimer = 0;
          let bomb = {
            x: drone.x,
            y: drone.y,
            radius: bomberDroneUpgrades.bombRadius,
            damage: bomberDroneUpgrades.bombDamage
          };
          drone.bombs.push(bomb);
          playRandomBombLaySound();
        }

        for (let i = drone.bombs.length - 1; i >= 0; i--) {
          let bomb = drone.bombs[i];
          for (let j = asteroids.length - 1; j >= 0; j--) {
            let asteroid = asteroids[j];
            let dx = bomb.x - asteroid.x;
            let dy = bomb.y - asteroid.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < bomb.radius + asteroid.size) {
              let actualDamage = Math.min(bomb.damage + damageBooster, asteroid.hitpoints);
              asteroid.hitpoints -= actualDamage;
              damageReport.bomberDrones += actualDamage;

              if (asteroid.hitpoints <= 0) {
                createExplosion(asteroid.x, asteroid.y, asteroid.hitpoints, asteroid.image);
                asteroids.splice(j, 1);
                score += 50;
                increaseXP(20);
              }
              createExplosion(bomb.x, bomb.y, 1);
              drone.bombs.splice(i, 1);
              break;
            }
          }
          if (bomb.x < 0 || bomb.x > canvas.width || bomb.y < 0 || bomb.y > canvas.height) {
            drone.bombs.splice(i, 1);
          }
        }
      });
    }

    function drawDrones() {
      drones.forEach(drone => {

        ctx.save();
        ctx.translate(drone.x, drone.y);
        ctx.rotate(drone.direction);
        ctx.drawImage(drone.image, -drone.size, -drone.size, drone.size * 2, drone.size * 2);
        ctx.restore();

        // ctx.save();
        // ctx.translate(drone.x, drone.y);
        // ctx.rotate(drone.direction);
        // ctx.beginPath();
        // ctx.moveTo(0, -drone.size);
        // ctx.lineTo(-drone.size, drone.size);
        // ctx.lineTo(drone.size, drone.size);
        // ctx.closePath();
        // ctx.fillStyle = 'cyan';
        // ctx.fill();
        // ctx.restore();

        ctx.fillStyle = 'cyan';
        for (let i = 0; i < drone.lasers.length; i++) {
          let laser = drone.lasers[i];
          ctx.fillRect(laser.x - 1, laser.y - 1, 2, 2);
        }
      });
    }

    function drawBomberDrones() {
      bomberDrones.forEach(drone => {

        ctx.save();
        ctx.translate(drone.x, drone.y);
        ctx.rotate(drone.direction);
        ctx.drawImage(drone.image, -drone.size, -drone.size, drone.size * 2, drone.size * 2);
        ctx.restore();

        // ctx.save();
        // ctx.translate(drone.x, drone.y);
        // ctx.rotate(drone.direction);
        // ctx.beginPath();
        // ctx.moveTo(0, -drone.size);
        // ctx.lineTo(-drone.size, drone.size);
        // ctx.lineTo(drone.size, drone.size);
        // ctx.closePath();
        // ctx.fillStyle = 'magenta';
        // ctx.fill();
        // ctx.restore();

        // Draw bombs
        ctx.fillStyle = 'orange';
        drone.bombs.forEach(bomb => {
          ctx.beginPath();
          ctx.arc(bomb.x, bomb.y, 5, 0, Math.PI * 2);
          ctx.fill();
        });
      });
    }



    function drawLives() {
      ctx.fillStyle = 'white';
      ctx.font = '20px Press Start 2P';
      ctx.textAlign = 'right';
      ctx.fillText('Lives: ' + lives, canvas.width - 180, canvas.height - 30);
    }

    function drawCoins() {
      ctx.fillStyle = 'white';
      ctx.font = '20px Press Start 2P';
      ctx.textAlign = 'left';
      let coinmessage = 'Coins: ' + coins;
      if (isMobile())
        coinmessage = coinmessage + '    tap for store';
      else
        coinmessage = coinmessage + "    'b' for store";

      ctx.fillText(coinmessage, 20, canvas.height - 30);
    }

    // function drawDrone() {
    //   ctx.save();
    //   ctx.translate(drone.x, drone.y);
    //   ctx.rotate(drone.direction);
    //   ctx.beginPath();
    //   ctx.moveTo(0, -drone.size);
    //   ctx.lineTo(-drone.size, drone.size);
    //   ctx.lineTo(drone.size, drone.size);
    //   ctx.closePath();
    //   ctx.fillStyle = 'cyan';
    //   ctx.fill();
    //   ctx.restore();

    //   // Draw drone lasers
    //   ctx.fillStyle = 'cyan';
    //   for (let i = 0; i < drone.lasers.length; i++) {
    //     let laser = drone.lasers[i];
    //     ctx.fillRect(laser.x - 1, laser.y - 1, 2, 2);
    //   }
    // }

    function saveTimeTaken(timeTaken) {
      localStorage.setItem('timeTaken', timeTaken);
    }

    function getTimeTaken() {
      return localStorage.getItem('timeTaken');
    }

    let timeTaken = 0;

    function endGame() {
      clearInterval(gameLoop);
      backgroundMusic.pause(); // Stop the background music
      gameEndTime = new Date();

      timeTaken = gameEndTime - gameStartTime; // Time in milliseconds
      saveTimeTaken(timeTaken); // Save the time taken to local storage

      console.log("this run: " + timeTaken);
      score *= modeScoreMultiplier;

      const topSixWeapons = Object.entries(damageReport)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 6)
        .map(([weapon, damage]) => ({ weapon, damage }));

      const gameData = {
        score: score,
        topWeapons: topSixWeapons
      };

      saveUserScore(userId, gameId, gameData);

      loadLeaderboard(gameId);
      document.getElementById('leaderboard-container').style.display = 'block';


      // now telegram only
      // turn off for now
      // handleEndGameOnServer();


      ctx.fillStyle = 'white';
      ctx.font = '40px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);
      ctx.font = '20px Arial';



      ctx.fillText(`Wave: ${wave}`, canvas.width / 2, canvas.height / 2 + 40);


      ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 70);
      ctx.fillText(`Asteroids Destroyed: ${asteroidsKilled}`, canvas.width / 2, canvas.height / 2 + 100);


      // Calculate and display coins for next round
      bonusCoins = Math.floor(score * 0.06);
      coins += bonusCoins;
      // ctx.fillText(`Bonus Coins for Next Round: ${bonusCoins}`, canvas.width / 2, canvas.height / 2 + 100);


      // Show the restart button
      restartButton.style.display = 'block';

      updateAchievementsAtEnd();

      // const a = new URLSearchParams(window.location.href)

      // if (a && a.get('inMsgId')) {
      //   fetch(`https://rzzuxqt0hi.execute-api.eu-central-1.amazonaws.com/Prod/api/telegram-webhook/test-score?userId=${a.get('userId')}&score=${score}&inMsgId=${a.get('inMsgId').split('#')[0]}`, {
      //     method: 'POST'
      //   })
      //     .then(response => response.json())
      //     .then(data => {
      //       console.log('Success:', data);
      //     })
      //     .catch(error => {
      //       console.error('Error:', error);
      //     });
      // }

    }


    function drawDamageReport() {
      ctx.fillStyle = 'white';
      ctx.font = '14px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(`Damage Report:`, 20, canvas.height - 340);

      const weaponDPM = {};
      const endTime = Date.now();
      damageReportStartTimes.lasers = gameStartTime;

      Object.keys(damageReport).forEach(weapon => {
        const activeTime = (endTime - damageReportStartTimes[weapon]) / 60000; // Time in minutes
        weaponDPM[weapon] = activeTime > 0 ? (damageReport[weapon] / activeTime).toFixed(2) : 0;
      });

      ctx.fillText(`Lasers: ${damageReport.lasers} (DPM: ${weaponDPM.lasers})`, 20, canvas.height - 320);
      ctx.fillText(`Explosive Lasers: ${damageReport.explosive} (DPM: ${weaponDPM.explosive})`, 20, canvas.height - 300);
      ctx.fillText(`Turret: ${damageReport.turret} (DPM: ${weaponDPM.turret})`, 20, canvas.height - 280);
      ctx.fillText(`Drones: ${damageReport.drones} (DPM: ${weaponDPM.drones})`, 20, canvas.height - 260);
      ctx.fillText(`Sonic Blast: ${damageReport.sonicBlast} (DPM: ${weaponDPM.sonicBlast})`, 20, canvas.height - 240);
      ctx.fillText(`Bomber Drones: ${damageReport.bomberDrones} (DPM: ${weaponDPM.bomberDrones})`, 20, canvas.height - 220);
      ctx.fillText(`Death Ray: ${damageReport.deathRay} (DPM: ${weaponDPM.deathRay})`, 20, canvas.height - 200);
      ctx.fillText(`Acid: ${damageReport.acid} (DPM: ${weaponDPM.acid})`, 20, canvas.height - 180);
      ctx.fillText(`Boomerang: ${damageReport.boomerang} (DPM: ${weaponDPM.boomerang})`, 20, canvas.height - 160);
      ctx.fillText(`Nano: ${damageReport.homing} (DPM: ${weaponDPM.homing})`, 20, canvas.height - 140);
      ctx.fillText(`Flamethrower: ${damageReport.flamethrower} (DPM: ${weaponDPM.flamethrower})`, 20, canvas.height - 120);
      ctx.fillText(`Chain Lightning: ${damageReport.chainlightning} (DPM: ${weaponDPM.chainlightning})`, 20, canvas.height - 100);
      ctx.fillText(`Explosive Rocket: ${damageReport.explosiverocket} (DPM: ${weaponDPM.explosiverocket})`, 20, canvas.height - 80);


    }

    function pauseGameForMarketplace() {
      clearInterval(gameLoop);
      marketplace.style.display = 'block';
      backgroundMusic.pause(); // Pause the background music

    }

    function exitMarketplace() {
      marketplace.style.display = 'none';
      invincible = true;
      invincibilityTimer = invincibilityDuration / 2;
      updateMarketplaceDisplay(); // Update display to reflect current levels
      gameLoop = setInterval(update, 1000 / 60); // Resume game loop
      backgroundMusic.play(); // Resume the background music

    }

    function upgrade(attribute) {
      const cost = 100;
      console.log("updgradeing with coins");
      if (coins >= cost) {
        coins -= cost;
        switch (attribute) {
          case 'lasers':
            ship.laserLevel++;
            break;
          case 'maxbullets':
            ship.maxBulletsLevel++;
            break;
          case 'explosivelaser':
            ship.explosiveLaserLevel++;
            break;
          case 'acceleration':
            ship.accelerationLevel++;
            ship.acceleration = 0.1 * ship.accelerationLevel;
            break;
          case 'laserCooldown':
            ship.laserCooldownLevel++;
            ship.maxBulletsLevel++;
            ship.laserCooldown = Math.max(5, ship.laserCooldown - 3);
            break;
          case 'rotationSpeed':
            ship.rotationSpeedLevel++;
            ship.rotationSpeed = 2 * ship.rotationSpeedLevel;
            break;
          case 'turretRange':
            turretUpgrades.range++;
            turret.range = 200 * turretUpgrades.range;
            break;
          case 'turretFireRate':
            turretUpgrades.fireRate++;
            turret.fireInterval = 120 / turretUpgrades.fireRate;
            break;
          case 'turretDamage':
            turretUpgrades.damage++;
            turret.damage = turretUpgrades.damage + 1;
            break;
          case 'boomerangSpeed':
            boomerangUpgrades.speed++;
            boomerang.speed = 2 * boomerangUpgrades.speed;
            break;
          case 'boomerangDamage':
            boomerangUpgrades.damage++;
            boomerang.damage = boomerangUpgrades.damage;
            break;

        }

        updateMarketplaceDisplay();
        updateCoinsDisplay();
      }
    }


    let fourthUpgradeUnlocked = false;

    function levelUp() {
      level++;
      xp = 0;  // Reset XP
      xpToNextLevel = Math.floor(xpToNextLevel * levelUpXPMultiplier); // Increase XP required for next level
      updateXPBar();

      // Generate three random upgrades
      let upgradesToRetrieve = 3;
      if (fourthUpgradeUnlocked)
        upgradesToRetrieve++;

      const upgrades = getRandomUpgrades(upgradesToRetrieve);

      // Display the level-up modal
      const levelUpModal = document.getElementById('levelUpModal');
      document.getElementById('upgrade1').textContent = `1. ${upgrades[0]}`;
      document.getElementById('upgrade2').textContent = `2. ${upgrades[1]}`;
      document.getElementById('upgrade3').textContent = `3. ${upgrades[2]}`;
      if (fourthUpgradeUnlocked) {
        document.getElementById('upgrade4').style.display = `block`;
        document.getElementById('upgrade4').textContent = `4. ${upgrades[3]}`;
      }

      levelUpModal.style.display = 'block';

      // Store upgrades in a global variable for later use
      window.levelUpgrades = upgrades;

      // Pause the game
      clearInterval(gameLoop);

      invincible = true;
      invincibilityTimer = invincibilityDuration;
    }



    function countTechnologies() {
      let count = 2;

      // These are all the achievements that have a specific weapon unlock assigned

      if (Achievements.reach_wave_2.reached) count++;
      if (Achievements.reach_wave_5.reached) count++;
      if (Achievements.reach_wave_10.reached) count++;
      if (Achievements.reach_wave_20.reached) count++;
      if (Achievements.complete_normal_mode.reached) count++;
      if (Achievements.acid_bomb_damage.reached) count++;
      if (Achievements.destroy_100_asteroids.reached) count++;
      if (Achievements.kill_5_aliens.reached) count++;
      if (Achievements.kill_15_aliens.reached) count++;
      if (Achievements.no_lives_lost.reached) count++;
      if (Achievements.death_ray_damage.reached) count++;
      if (Achievements.complete_meteor_normal_mode.reached) count++;
      if (Achievements.complete_meteor_hard_mode.reached) count++;
      if (Achievements.complete_planet_normal_mode.reached) count++;
      if (Achievements.complete_planet_hard_mode.reached) count++;

      if (Achievements.complete_hard_mode.reached) count++;
      if (Achievements.complete_hero_mode.reached) count++;
      if (Achievements.drone_damage.reached) count++;
      if (Achievements.laser_damage.reached) count++;

      return count;
    }

    let damageBooster = 0;

    function getRandomUpgrades(count) {
      const availableUpgrades = [
        ...(getUpgradeCount('laser') <= 9 ? ['Increase Laser Level', 'Decrease Laser Cooldown'] : []),
        'Increase Rotation Speed',
        ...(activeWeaponClasses.includes('turret') ? (getUpgradeCount('turret') <= 9 ? ['Increase Turret Range', 'Increase Turret Firerate', 'Increase Turret Damage'] : []) : ['Activate Turret'])

      ];

      if (Achievements.reach_wave_2.reached)
        availableUpgrades.push(...(activeWeaponClasses.includes('bomberdrone') ? (getUpgradeCount('bomberdrone') <= 9 ? ['Increase Bomber Drone Bomb Radius', 'Increase Bomber Drone Bomb Damage'] : []) : ['Activate Bomber Drone'])
        );
      if (Achievements.reach_wave_5.reached)
        availableUpgrades.push(...(activeWeaponClasses.includes('freeze') ? (getUpgradeCount('freeze') <= 9 ? ['Increase Freeze Duration', 'Decrease Freeze Cooldown'] : []) : ['Activate Freeze Effect']));
      if (Achievements.laser_damage.reached)
        availableUpgrades.push(...(activeWeaponClasses.includes('explosive') ? (getUpgradeCount('explosive') <= 9 ? ['Increase Explosive Laser Level'] : []) : ['Activate Explosive Laser']));
      if (Achievements.reach_wave_10.reached)
        availableUpgrades.push(...(activeWeaponClasses.includes('sonic') ? (getUpgradeCount('sonic') <= 9 ? ['Increase Sonic Blast Range', 'Increase Sonic Blast Damage', 'Decrease Sonic Blast Cooldown'] : []) : ['Activate Sonic Blast']));
      if (Achievements.reach_wave_20.reached)
        availableUpgrades.push(...(activeWeaponClasses.includes('boomerang') ? (getUpgradeCount('boomerang') <= 9 ? ['Increase Boomerang Speed', 'Increase Boomerang Damage'] : []) : ['Activate Boomerang']));
      if (Achievements.complete_normal_mode.reached)
        availableUpgrades.push(...(activeWeaponClasses.includes('acid') ? (getUpgradeCount('acid') <= 9 ? ['Increase Acid Bomb Duration', 'Decrease Acid Bomb Cooldown', 'Increase Acid Bomb Size'] : []) : ['Activate Acid Bomb']));
      if (Achievements.destroy_100_asteroids.reached)
        availableUpgrades.push(...(activeWeaponClasses.includes('drone') ? (getUpgradeCount('drone') <= 9 ? ['Increase Drone Firerate'] : []) : ['Activate Drone']));
      if (Achievements.kill_5_aliens.reached)
        availableUpgrades.push(...(activeWeaponClasses.includes('deathray') ? (getUpgradeCount('deathray') <= 9 ? ['Increase Death Ray Length', 'Increase Death Ray Width', 'Decrease Death Ray Cooldown'] : []) : ['Activate Death Ray']));
      if (Achievements.complete_planet_hard_mode.reached)
        availableUpgrades.push(...(activeWeaponClasses.includes('explosiverocket') ? (getUpgradeCount('explosiverocket') <= 9 ? ['Increase Explosive Rocket Damage', 'Increase Explosive Rocket Radius', 'Decrease Explosive Rocket Cooldown'] : []) : ['Activate Explosive Rocket']));

      if (Achievements.kill_15_aliens.reached)
        availableUpgrades.push(...(activeWeaponClasses.includes('chainlightning') ? (getUpgradeCount('chainlightning') <= 9 ? ['Increase Chain Lightning Range', 'Increase Chain Lightning Damage', 'Increase Chain Lightning Bounces', 'Decrease Chain Lightning Cooldown'] : []) : ['Activate Chain Lightning']));

      if (Achievements.no_lives_lost.reached)
        availableUpgrades.push(...(activeWeaponClasses.includes('homingmissile') ? (getUpgradeCount('homingmissile') <= 9 ? ['Boost Nano Swarm', 'Decrease Nano Swarm Cooldown'] : []) : ['Activate Nano Swarm']));


      if (Achievements.acid_bomb_damage.reached)
        availableUpgrades.push(...(activeWeaponClasses.includes('flamethrower') ? (getUpgradeCount('flamethrower') <= 9 ? ['Increase Flamethrower Range', 'Increase Flamethrower Damage', 'Decrease Flamethrower Cooldown'] : []) : ['Activate Flamethrower']));

      if (!fourthUpgradeUnlocked && Achievements.death_ray_damage.reached)
        availableUpgrades.push('Extra Upgrade Choice');
      if ((activeWeaponClasses.includes('drone') || activeWeaponClasses.includes('bomberdrone')) && Achievements.drone_damage.reached)
        availableUpgrades.push('Drone Army');
      if (Achievements.complete_meteor_normal_mode.reached && activeWeaponClasses.includes('turret'))
        availableUpgrades.push('Double Turret');
      if (Achievements.complete_planet_normal_mode.reached && activeWeaponClasses.includes('turret'))
        availableUpgrades.push('Triple Turret');
      if (Achievements.complete_hard_mode.reached)
        availableUpgrades.push('Damage Booster');
      if (!fourthUpgradeUnlocked && Achievements.complete_planet_hard_mode.reached)
        availableUpgrades.push('Extra Upgrade Choice');
      const upgrades = [];
      for (let i = 0; i < count; i++) {
        if (availableUpgrades.length === 0) break; // Exit loop if no more upgrades available
        const randomIndex = Math.floor(Math.random() * availableUpgrades.length);
        upgrades.push(availableUpgrades[randomIndex]);
        availableUpgrades.splice(randomIndex, 1);
      }
      return upgrades;
    }

    function applyUpgrade(upgrade) {
      const now = Date.now();

      switch (upgrade) {
        case 'Increase Laser Level':
          ship.laserLevel++;
          break;
        case 'Decrease Laser Cooldown':
          ship.laserCooldownLevel++;
          ship.maxBulletsLevel++;
          ship.laserCooldown = Math.max(5, ship.laserCooldown - 3);
          break;
        case 'Increase Rotation Speed':
          ship.rotationSpeedLevel++;
          ship.rotationSpeed = 2 * ship.rotationSpeedLevel;
          break;
        case 'Activate Explosive Laser':
          activateWeaponClass('explosive');
          damageReportStartTimes.explosive = now;
          break;
        case 'Increase Explosive Laser Level':
          ship.explosiveLaserLevel++;
          break;
        case 'Activate Turret':
          activateWeaponClass('turret');
          damageReportStartTimes.turret = now;
          break;
        case 'Increase Turret Range':
          turretUpgrades.range++;
          turret.range = 200 * turretUpgrades.range;
          break;
        case 'Increase Turret Firerate':
          turretUpgrades.fireRate++;
          turret.fireInterval = 120 / turretUpgrades.fireRate;
          break;
        case 'Increase Turret Damage':
          turretUpgrades.damage++;
          turret.damage = turretUpgrades.damage;
          break;
        case 'Activate Drone':
          activateWeaponClass('drone');
          damageReportStartTimes.drones = now;
          break;
        case 'Increase Drone Firerate':
          droneUpgrades.laserInterval++;
          drones.forEach(drone => {
            drone.laserInterval = 80 / droneUpgrades.laserInterval;
          });
          break;
        case 'Activate Sonic Blast':
          activateWeaponClass('sonic');
          damageReportStartTimes.sonicBlast = now;
          break;
        case 'Increase Sonic Blast Range':
          sonicBlast.range += 50;
          sonicBlast.rangeLevel++;
          break;
        case 'Increase Sonic Blast Damage':
          sonicBlast.damageLevel++;
          sonicBlast.damage++;
          break;
        case 'Decrease Sonic Blast Cooldown':
          sonicBlast.cooldown = Math.max(60, sonicBlast.cooldown - 30);
          sonicBlast.cooldownLevel++;
          break;
        case 'Activate Bomber Drone':
          activateWeaponClass('bomberdrone');
          damageReportStartTimes.bomberDrones = now;
          break;
        case 'Increase Bomber Drone Speed':
          bomberDroneUpgrades.speed += 0.2;
          bomberDrones.forEach(drone => {
            drone.speed = 0.5 * bomberDroneUpgrades.speed;
          });
          break;
        case 'Increase Bomber Drone Bomb Radius':
          bomberDroneUpgrades.bombRadius += 10;
          bomberDroneUpgrades.bombRadiusLevel++;
          break;
        case 'Increase Bomber Drone Bomb Damage':
          bomberDroneUpgrades.bombDamage++;
          break;
        case 'Activate Death Ray':
          activateWeaponClass('deathray');
          damageReportStartTimes.deathRay = now;
          break;
        case 'Increase Death Ray Length':
          deathRayUpgrades.length++;
          deathRay.length = 1000 * deathRayUpgrades.length;
          break;
        case 'Increase Death Ray Width':
          deathRayUpgrades.width++;
          deathRay.width = 50 * deathRayUpgrades.width;
          break;
        case 'Decrease Death Ray Cooldown':
          deathRayUpgrades.cooldown++;
          deathRay.cooldown = Math.max(60, 300 - 30 * deathRayUpgrades.cooldown);
          break;
        case 'Activate Acid Bomb':
          activateWeaponClass('acid');
          damageReportStartTimes.acid = now;
          break;
        case 'Increase Acid Bomb Duration':
          acidBombUpgrades.duration++;
          acidBomb.duration = 300 * acidBombUpgrades.duration;
          break;
        case 'Decrease Acid Bomb Cooldown':
          acidBombUpgrades.cooldown++;
          acidBomb.cooldown = Math.max(60, 300 - 30 * acidBombUpgrades.cooldown);
          break;
        case 'Increase Acid Bomb Size':
          acidBombUpgrades.size++;
          acidBomb.size = 20 + (20 * acidBombUpgrades.size);
          break;
        case 'Activate Explosive Rocket':
          activateWeaponClass('explosiverocket');
          damageReportStartTimes.explosiveRocket = now;
          break;
        case 'Increase Explosive Rocket Damage':
          explosiveRocketUpgrades.damage++;
          explosiveRocket.damage = 10 * explosiveRocketUpgrades.damage;
          break;
        case 'Increase Explosive Rocket Radius':
          explosiveRocketUpgrades.radius++;
          explosiveRocket.radius = 50 * explosiveRocketUpgrades.radius;
          break;
        case 'Decrease Explosive Rocket Cooldown':
          explosiveRocketUpgrades.cooldown++;
          explosiveRocket.cooldown = Math.max(30, 120 - 10 * explosiveRocketUpgrades.cooldown);
          break;
        case 'Activate Freeze Effect':
          activateWeaponClass('freeze');
          damageReportStartTimes.freeze = now;
          break;
        case 'Increase Freeze Duration':
          freezeEffectUpgrades.duration++;
          freezeEffect.duration = 20 + (10 * freezeEffectUpgrades.duration);
          break;
        case 'Decrease Freeze Cooldown':
          freezeEffectUpgrades.cooldown++;
          freezeEffect.cooldown = Math.max(60, 600 - 60 * freezeEffectUpgrades.cooldown);
          break;
        case 'Activate Boomerang':
          activateWeaponClass('boomerang');
          damageReportStartTimes.boomerang = now;
          break;
        case 'Increase Boomerang Speed':
          boomerangUpgrades.speed++;
          boomerang.speed = 2 * boomerangUpgrades.speed;
          break;
        case 'Increase Boomerang Damage':
          boomerangUpgrades.damage++;
          boomerang.damage = boomerangUpgrades.damage;
          break;
        case 'Activate Nano Swarm':
          activateWeaponClass('homingmissile');
          damageReportStartTimes.homing = now;
          break;
        case 'Boost Nano Swarm':
          homingMissileUpgrades.damage++;
          homingMissileUpgrades.speed++;
          break;
        case 'Decrease Nano Swarm Cooldown':
          homingMissileUpgrades.cooldown++;
          homingMissile.cooldown = Math.max(20, 120 - 30 * homingMissileUpgrades.cooldown);
          break;
        case 'Double Turret':
          doubleTurret = true;
          break;
        case 'Triple Turret':
          tripleTurret = true;
          break;
        case 'Drone Army':
          buyDrone();
          buyBomberDrone();
          break;
        case 'Damage Booster':
          damageBooster++;
          break;
        case 'Extra Upgrade Choice':
          fourthUpgradeUnlocked = true;
          break;
        case 'Activate Flamethrower':
          activateWeaponClass('flamethrower');
          damageReportStartTimes.flamethrower = now;
          break;
        case 'Increase Flamethrower Range':
          flamethrowerUpgrades.range++;
          flamethrower.range = 100 * flamethrowerUpgrades.range;
          break;
        case 'Increase Flamethrower Damage':
          flamethrowerUpgrades.damage++;
          flamethrower.damagePerSecond++;
          flamethrower.damage = flamethrowerUpgrades.damage;
          break;
        case 'Decrease Flamethrower Cooldown':
          flamethrowerUpgrades.cooldown++;
          flamethrower.cooldown = Math.max(1, 10 - flamethrowerUpgrades.cooldown);
          break;

        case 'Activate Chain Lightning':
          activateWeaponClass('chainlightning');
          damageReportStartTimes.chainlightning = now;
          break;
        case 'Increase Chain Lightning Range':
          chainLightningUpgrades.range++;
          chainLightning.range = 100 * chainLightningUpgrades.range;
          break;
        case 'Increase Chain Lightning Damage':
          chainLightningUpgrades.damage++;
          chainLightning.damage = 5 * chainLightningUpgrades.damage;
          break;
        case 'Increase Chain Lightning Bounces':
          chainLightningUpgrades.bounces++;
          chainLightning.bounces = 1 + chainLightningUpgrades.bounces;
          break;
        case 'Decrease Chain Lightning Cooldown':
          chainLightningUpgrades.cooldown++;
          chainLightning.cooldown = Math.max(60, 300 - 30 * chainLightningUpgrades.cooldown);
          break;

      }
    }

    let damageReportStartTimes = {};

    // Initialize total damage for each weapon
    function initializeWeaponDamageTracking() {
      const weaponClasses = ['explosive', 'turret', 'drone', 'sonic', 'bomberdrone', 'deathray', 'acid', 'freeze', 'boomerang', 'homingmissile', 'flamethrower', 'chainlightning', 'explosiverocket'];
      weaponClasses.forEach(weapon => {
        damageReport[weapon] = 0;
        damageReportStartTimes[weapon] = null;
      });
    }

    initializeWeaponDamageTracking();



    function activateWeaponClass(weaponClass) {
      // temporarily remove restrictions
      if (!activeWeaponClasses.includes(weaponClass)) {
        activeWeaponClasses.push(weaponClass);
        // damageReportStartTimes[weaponClass] = Date.now();

        switch (weaponClass) {
          case 'explosive':
            ship.explosiveLaserLevel = 1;
            break;
          case 'turret':
            turret.bought = true;
            turretUpgrades.range = 1;
            turretUpgrades.fireRate = 1;
            turretUpgrades.damage = 1;
            break;
          case 'drone':
            buyDrone();
            break;
          case 'bomberdrone':
            bomberDroneUpgrades = {
              speed: 1,
              bombRadius: 50,
              bombRadiusLevel: 1,
              bombDamage: 2
            };
            buyBomberDrone();
            break;
          case 'sonic':
            sonicBlast.range = 200;
            sonicBlast.damage = 1;
            sonicBlast.cooldown = 300;
            break;
          case 'deathray':
            deathRay.length = 1000;
            deathRay.width = 50;
            deathRay.cooldown = 300;
            break;
          case 'homingmissile':
            homingMissile.cooldown = 120;
            homingMissile.timer = 0;
            break;
          case 'freeze':
            freezeEffect.duration = 30;
            freezeEffect.cooldown = 600;
            break;
          case 'boomerang':
            activateBoomerang();
            break;

        }

      }
    }
    // Update function to draw active weapon classes with cooldown indicators
    function drawActiveWeaponClasses() {
      const container = document.getElementById('activeWeaponClassesContainer');
      container.innerHTML = ''; // Clear previous content

      for (const weaponClass of activeWeaponClasses) {
        const iconContainer = document.createElement('div');
        iconContainer.classList.add('iconContainer');

        const icon = document.createElement('div');
        icon.classList.add('weaponClassIcon', `icon-${weaponClass.toLowerCase().replace(/\s+/g, '')}`);

        // Create a span element to display the number of upgrades
        const upgradeCount = document.createElement('span');
        upgradeCount.classList.add('upgradeCount');
        upgradeCount.textContent = getUpgradeCount(weaponClass); // Get the number of upgrades for the weapon class

        // Append the icon and upgrade count to the container
        iconContainer.appendChild(icon);
        iconContainer.appendChild(upgradeCount);
        container.appendChild(iconContainer);
      }
    }

    function drawCooldownIndicator(x, y, radius, cooldown, maxCooldown) {
      if (cooldown <= 0) return;

      const startAngle = -Math.PI / 2; // Start at the top
      const endAngle = startAngle + (2 * Math.PI * (1 - cooldown / maxCooldown));

      ctx.save();
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(x, y, radius, startAngle, endAngle);
      ctx.stroke();
      ctx.restore();
    }



    function getUpgradeCount(weaponClass) {
      switch (weaponClass) {
        case 'explosive':
          return ship.explosiveLaserLevel;
        case 'turret':
          return turretUpgrades.range + turretUpgrades.fireRate + turretUpgrades.damage - 2;
        case 'drone':
          return droneUpgrades.laserInterval; // Assuming this is the main upgrade for drones
        case 'sonic':
          return sonicBlast.rangeLevel + sonicBlast.damageLevel + sonicBlast.cooldownLevel - 2; // Example calculation
        case 'bomberdrone':
          return bomberDroneUpgrades.speed + bomberDroneUpgrades.bombRadiusLevel + bomberDroneUpgrades.bombDamage - 3;
        case 'deathray':
          return deathRayUpgrades.length + deathRayUpgrades.width + deathRayUpgrades.cooldown - 2;
        case 'acid':
          return acidBombUpgrades.duration + acidBombUpgrades.cooldown + acidBombUpgrades.size - 2;
        case 'freeze':
          return freezeEffectUpgrades.duration + freezeEffectUpgrades.cooldown - 1;
        case 'boomerang':
          return boomerangUpgrades.speed + boomerangUpgrades.damage - 1;
        case 'homingmissile':
          return homingMissileUpgrades.speed + homingMissileUpgrades.damage + homingMissileUpgrades.cooldown - 2;
        case 'flamethrower':
          return flamethrowerUpgrades.range + flamethrowerUpgrades.damage + flamethrowerUpgrades.cooldown - 2;
        case 'chainlightning':
          return chainLightningUpgrades.range + chainLightningUpgrades.damage + chainLightningUpgrades.bounces + chainLightningUpgrades.cooldown - 3;
        case 'explosiverocket':
          return explosiveRocketUpgrades.damage + explosiveRocketUpgrades.radius + explosiveRocketUpgrades.cooldown - 2;

        default:
          return 0;
      }
    }



    function updateCoinsDisplay() {
      coinsDisplay.textContent = coins;
    }


    // Draw lasers
    function drawLasers() {
      ctx.fillStyle = 'red';
      for (let i = 0; i < ship.lasers.length; i++) {
        ctx.fillRect(ship.lasers[i].x - 1, ship.lasers[i].y - 1, ship.laserLevel + 3, ship.laserLevel + 3); // Drawing lasers as small squares for better collision detection
      }
    }

    // Update lasers
    function updateLasers() {
      for (let i = 0; i < ship.lasers.length; i++) {
        let laser = ship.lasers[i];
        laser.x += 10 * Math.sin(laser.rotation * Math.PI / 180);
        laser.y -= 10 * Math.cos(laser.rotation * Math.PI / 180);

        // Remove lasers that are off-screen
        if (laser.x < 0 || laser.x > canvas.width || laser.y < 0 || laser.y > canvas.height) {
          ship.lasers.splice(i, 1);
          i--;
        }
      }
    }

    function isColliding(obj1, obj2) {
      if (obj1.radius) {
        // Circular collision detection for sonic blast wave
        let dx = obj1.x - obj2.x;
        let dy = obj1.y - obj2.y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        return distance < obj1.radius + obj2.size;
      } else {
        // Original collision detection
        let dx = obj1.x - obj2.x;
        let dy = obj1.y - obj2.y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        return distance < (obj1.size || 1) + obj2.size;
      }
    }


    function drawPixelatedExplosion(x, y, size) {
      const canvas = document.createElement('canvas');
      // const ctx = canvas.getContext('2d');
      const pixelSize = 4; // Adjust pixel size to your preference

      canvas.width = size;
      canvas.height = size;

      // Draw explosion on the off-screen canvas
      ctx.fillStyle = 'orange';
      ctx.beginPath();
      ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
      ctx.fill();

      // Get the image data
      const imageData = ctx.getImageData(0, 0, size, size);

      // Create a new canvas for pixelated effect
      const pixelCanvas = document.createElement('canvas');
      const pixelCtx = pixelCanvas.getContext('2d');

      pixelCanvas.width = size;
      pixelCanvas.height = size;

      // Draw pixelated effect
      for (let y = 0; y < size; y += pixelSize) {
        for (let x = 0; x < size; x += pixelSize) {
          const pixelIndex = (y * size + x) * 4;
          const r = imageData.data[pixelIndex];
          const g = imageData.data[pixelIndex + 1];
          const b = imageData.data[pixelIndex + 2];
          const a = imageData.data[pixelIndex + 3];

          pixelCtx.fillStyle = `rgba(${r},${g},${b},${a / 255})`;
          pixelCtx.fillRect(x, y, pixelSize, pixelSize);
        }
      }

      // Draw the pixelated explosion on the main canvas
      ctx.drawImage(pixelCanvas, 0, 0);

      // Draw the pixelated canvas onto the game canvas
      ctx.drawImage(canvas, x - size / 2, y - size / 2);
    }

    // Usage
    // drawPixelatedExplosion(100, 100, 64);


    function drawScore() {
      ctx.fillStyle = 'white';
      ctx.font = '20px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(`Wave: ${wave}`, canvas.width - 120, canvas.height - 30);

      if (!isMobile())
        ctx.fillText("\'m\' to toggle music \'n\' sound \'v\' volume  'p\' pause 'i\' info", 20, canvas.height - 30);

    }



    // Draw wave message
    function drawWaveMessage() {
      ctx.fillStyle = 'white';
      ctx.font = '40px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Wave ' + wave, canvas.width / 2, canvas.height / 2);
    }

    let chanceForSmallAsteroid = 3;
    let chanceForVerySmallAsteroid = 1;
    let chanceForHardenedAsteroid = 5;
    let chanceForVeryHardenedAsteroid = 2; // Example chance for very hardened asteroid
    let chanceForMegaHardenedAsteroid = 1; // Example chance for mega hardened asteroid

    function createSmallerAsteroids(x, y, size, speed, hitpoints) {
      const baseAngles = [0, Math.PI / 2, Math.PI, (3 * Math.PI) / 2];
      const speedMultiplier = 0.6; // Decrease speed for smaller asteroids
      const newSize = size / 2; // New size for smaller asteroids

      for (let i = 0; i < 3; i++) {
        const angleVariation = (Math.random() - 0.5) * 0.7; // Random variation between -0.1 and 0.1 radians
        const angle = baseAngles[i] + angleVariation;

        let asteroid = {
          x: x,
          y: y,
          size: newSize,
          speed: speed * speedMultiplier,
          dx: Math.cos(angle) * speed * speedMultiplier,
          dy: Math.sin(angle) * speed * speedMultiplier,
          hitpoints: hitpoints,
          initialHitpoints: hitpoints, // Store the initial hitpoints
          color: 'gray'
        };
        asteroids.push(asteroid);
      }
    }

    const asteroidImages = [];

    // preloadAsteroidImages();

    // function preloadAsteroidImages() {
    //   const imagePaths = [
    //     'roids/8bitroid_2657.png',
    //     'roids/8bitroid_3590.png',
    //     'roids/8bitroid_4692.png',
    //     'roids/8bitroid_5715.png',
    //     'roids/8bitroid_6560.png',
    //     'roids/8bitroid_7406.png',
    //     'roids/8bitroid_8170.png',
    //     'roids/8bitroid_8775.png',
    //     'roids/8bitroid_8824.png',
    //     'roids/8bitroid_8892.png',
    //     'roids/8bitroid_9074.png',
    //     'roids/8bitroid_9292.png',
    //     'roids/8bitroid_9449.png',
    //     'roids/8bitroid_9460.png',

    //   ];

    //   imagePaths.forEach(path => {
    //     const image = new Image();
    //     image.src = path;
    //     asteroidImages.push(image);
    //   });
    // }


    const droneImages = {
      regularDrone: 'icons/laserdrone.png',
      bomberDrone: 'icons/bomberdrone.png',
      nanoDrone: 'icons/nanodrone.png',
    };

    function preloadDroneImages() {
      for (const droneType in droneImages) {
        const image = new Image();
        image.src = droneImages[droneType];
        droneImages[droneType] = image;
      }
    }

    // Call the preloadDroneImages function before starting the game
    preloadDroneImages();

    function showArrow(side) {
      const leftArrow = document.getElementById('leftArrow');
      const rightArrow = document.getElementById('rightArrow');

      if (side === 'left') {
        leftArrow.style.display = 'block';
        rightArrow.style.display = 'none';
      } else {
        leftArrow.style.display = 'none';
        rightArrow.style.display = 'block';
      }

      setTimeout(() => {
        leftArrow.style.display = 'none';
        rightArrow.style.display = 'none';
        createAsteroids(side);
      }, 700);
    }

    function createAsteroids(side) {

      const asteroidImages = [
        // 'roids/8bitroid_2657.png',
        // 'roids/8bitroid_3590.png',
        // 'roids/8bitroid_4692.png',
        // 'roids/8bitroid_5715.png',
        // 'roids/8bitroid_6560.png',
        // 'roids/8bitroid_7406.png',
        // 'roids/8bitroid_8170.png',
        // 'roids/8bitroid_8775.png',
        // 'roids/8bitroid_8824.png',
        // 'roids/8bitroid_8892.png',
        'roids/8bitroid_9074.png',
        'roids/8bitroid_9292.png',
        'roids/8bitroid_9449.png',
        'roids/8bitroid_9460.png',

        // Add more asteroid image paths as needed
      ];


      let numberOfAsteroids = 10 + (wave - 1) * 1.8 + meteorBooster;
      if (meteorMode) {
        numberOfAsteroids += 35;
      }



      for (let i = 0; i < numberOfAsteroids; i++) {
        let isLargeAsteroid = Math.random() < 0.1; // 10% chance for a large asteroid
        let isSmallAsteroid = Math.random() * 100 < chanceForSmallAsteroid;
        let isVerySmallAsteroid = Math.random() * 100 < chanceForVerySmallAsteroid;
        let isHardenedAsteroid = Math.random() * 100 < chanceForHardenedAsteroid;
        let isVeryHardenedAsteroid = Math.random() * 100 < chanceForVeryHardenedAsteroid;
        let isMegaHardenedAsteroid = Math.random() * 100 < chanceForMegaHardenedAsteroid;
        let dx = 1;
        let dy = 1;
        let asteroidSize = isLargeAsteroid ? 40 : isSmallAsteroid ? 10 : 20;
        let asteroidSpeedMultiplier = isSmallAsteroid ? 0.3 : isLargeAsteroid ? 0.05 : 0.1;

        const randomIndex = Math.floor(Math.random() * asteroidImages.length);
        const asteroidImage = asteroidImages[randomIndex];

        if (isVerySmallAsteroid) {
          asteroidSize = 5;
          asteroidSpeedMultiplier = 0.5;
        }



        let x, y;
        let spawnArea = Math.random();
        if (!meteorMode) {
          if (spawnArea < 0.25) {
            // Top edge
            x = Math.random() * canvas.width;
            y = Math.random() * (canvas.height * 0.1);
          } else if (spawnArea < 0.5) {
            // Right edge
            x = canvas.width * 0.9 + Math.random() * (canvas.width * 0.1);
            y = Math.random() * canvas.height;
          } else if (spawnArea < 0.75) {
            // Bottom edge
            x = Math.random() * canvas.width;
            y = canvas.height * 0.9 + Math.random() * (canvas.height * 0.1);
          } else {
            // Left edge
            x = Math.random() * (canvas.width * 0.1);
            y = Math.random() * canvas.height;
          }
        } else {
          x = side === 'left' ? 0 : canvas.width;
          y = Math.random() * canvas.height;
          dx = side === 'left' ? Math.random() * 2 : -Math.random() * 2;
          dy = (Math.random() * 2 - 1);

        }

        let hitpoints;
        let color;

        if (isLargeAsteroid) {
          hitpoints = wave; // Higher hit points for larger asteroids
          color = 'darkgray';
        } else if (isMegaHardenedAsteroid) {
          hitpoints = 10 + wave;
          color = '#301934'; // Very dark purple for mega hardened asteroids
        } else if (isVeryHardenedAsteroid) {
          hitpoints = 15;
          color = '#0A1414'; // Very dark green color for very hardened asteroids
        } else if (isHardenedAsteroid) {
          hitpoints = Math.floor(Math.random() * 5) + 3; // Random hitpoints between 5 and 8
          color = '#172727'; // Dark green color for hardened asteroids
        } else {
          hitpoints = 1;
          color = 'gray';
        }

        let asteroid = {
          id: Date.now() + Math.random(), // Generate a unique ID for each asteroid
          x: x,
          y: y,
          size: asteroidSize,
          speed: 2 * Math.pow(1.02, wave - 1) * asteroidDifficultySpeedMultiplier,
          dx: dx * (Math.random() * 2 - 1) * asteroidSpeedMultiplier * Math.pow(1.02, wave - 1) * asteroidDifficultySpeedMultiplier,
          dy: dy * (Math.random() * 2 - 1) * asteroidSpeedMultiplier * Math.pow(1.02, wave - 1) * asteroidDifficultySpeedMultiplier,
          hitpoints: hitpoints,
          initialHitpoints: hitpoints,
          color: color,
          isLarge: isLargeAsteroid,
          image: asteroidImage
        };

        asteroids.push(asteroid);
      }

      chanceForSmallAsteroid += 0.5;
      chanceForVerySmallAsteroid += 0.1;
      chanceForHardenedAsteroid += 0.5;
      chanceForVeryHardenedAsteroid += 0.2; // Increase the chance for very hardened asteroids
      chanceForMegaHardenedAsteroid += 0.1; // Increase the chance for mega hardened asteroids

      // Trigger the asteroid cluster every few waves (e.g., every 5 waves)
      if (wave % 3 === 0) {
        createAsteroidCluster();
      }


      if (wave % 7 === 0) {
        createSlowCluster();
      }

      if (wave % 10 === 0 && !alien) {
        alien = {
          x: 20,
          y: 50,
          size: 50,
          speed: 1,
          direction: Math.PI / 2,
          shootTimer: 0,
          hitpoints: wave + 5,
          shootInterval: 120 // Adjust the shooting interval as desired
        };
      }

    }


    function createAsteroidCluster() {
      const clusterSize = 10; // Number of asteroids in the cluster
      let clusterSpeed = 1.4 * Math.pow(1.02, wave - 1); // Base speed for the cluster
      // half speed clusters in easy
      if (currentMode == GameModes.EASY)
        clusterSpeed *= 0.5;
      const speedVariation = 0.02; // Speed variation percentage (1%)
      const angleVariation = Math.PI / 8; // Angle variation (in radians)

      // Determine the starting corner (top-left, top-right, bottom-left, bottom-right)
      const corners = [
        { x: 0, y: 0 },
        { x: canvas.width, y: 0 },
        { x: 0, y: canvas.height },
        { x: canvas.width, y: canvas.height }
      ];
      const startCorner = corners[Math.floor(Math.random() * corners.length)];

      // Determine the target corner (opposite of the starting corner)
      const targetCorner = {
        x: canvas.width - startCorner.x,
        y: canvas.height - startCorner.y
      };

      for (let i = 0; i < clusterSize; i++) {
        // Calculate a random variation in speed
        const speedMultiplier = 1 + (Math.random() * 2 - 1) * speedVariation;

        // Calculate a random variation in angle
        const angleOffset = (Math.random() * 2 - 1) * angleVariation;

        // Calculate the direction vector based on the target corner and angle variation
        const dx = Math.cos(Math.atan2(targetCorner.y - startCorner.y, targetCorner.x - startCorner.x) + angleOffset);
        const dy = Math.sin(Math.atan2(targetCorner.y - startCorner.y, targetCorner.x - startCorner.x) + angleOffset);

        // Create the asteroid with slightly varied speed and angle
        let asteroid = {
          x: startCorner.x + i * 4,
          y: startCorner.y + i * 4,
          size: 20,
          speed: clusterSpeed * speedMultiplier,
          dx: dx * clusterSpeed * speedMultiplier,
          dy: dy * clusterSpeed * speedMultiplier,
          hitpoints: 5, // Hit points for larger asteroids
          initialHitpoints: 5, // Store the initial hitpoints
          color: 'gray'
        };

        asteroids.push(asteroid);
      }
    }
    function createSlowCluster() {
      const clusterSize = 3; // Number of asteroids in the cluster
      const clusterSpeed = 0.5; // Speed of the cluster
      const asteroidHitpoints = 50; // Hitpoints of each asteroid in the cluster
      const asteroidSize = 40; // Size of each asteroid in the cluster

      // Determine the starting position (left or right)
      const startX = Math.random() < 0.5 ? 0 : canvas.width;
      const startY = canvas.height / 2;

      // Determine the direction (left to right or right to left)
      const direction = startX === 0 ? 1 : -1;

      for (let i = 0; i < clusterSize; i++) {
        let asteroid = {
          x: startX,
          y: startY + (i - Math.floor(clusterSize / 2)) * asteroidSize * 2,
          size: asteroidSize,
          speed: clusterSpeed,
          dx: direction,
          dy: 0,
          hitpoints: asteroidHitpoints,
          initialHitpoints: asteroidHitpoints,
          color: 'darkgray'
        };

        asteroids.push(asteroid);
      }
    }


    // Update asteroids
    function updateAsteroids() {
      if (!freezeEffect.active) {
        for (let i = 0; i < asteroids.length; i++) {
          applyGravity(asteroids[i]);

          asteroids[i].x += asteroids[i].dx * asteroids[i].speed;
          asteroids[i].y += asteroids[i].dy * asteroids[i].speed;

          if (!meteorMode) {
            // Wrap asteroids around the screen
            if (asteroids[i].x < 0) {
              asteroids[i].x = canvas.width;
            } else if (asteroids[i].x > canvas.width) {
              asteroids[i].x = 0;
            }
            if (asteroids[i].y < 0) {
              asteroids[i].y = canvas.height;
            } else if (asteroids[i].y > canvas.height) {
              asteroids[i].y = 0;
            }
          } else {

            if (
              asteroids[i].x < 0 ||
              asteroids[i].x > canvas.width ||
              asteroids[i].y < 0 ||
              asteroids[i].y > canvas.height
            ) {
              asteroids.splice(i, 1);
              i--;
            }

          }

        }
      }
    }

    // function spawnAliens(wave) {
    //   const aliensToSpawn = getAliensToSpawn(wave);
    //   console.log(aliensToSpawn);
    //   const corners = [
    //     { x: 0, y: 0 }, // Top-left corner
    //     { x: canvas.width, y: 0 }, // Top-right corner
    //     { x: 0, y: canvas.height }, // Bottom-left corner
    //     { x: canvas.width, y: canvas.height } // Bottom-right corner
    //   ];

    //   for (let i = 0; i < aliensToSpawn; i++) {
    //     const cornerIndex = i % corners.length;
    //     const { x, y } = corners[cornerIndex];

    //     let newAlien = {
    //       x: x,
    //       y: y,
    //       size: 30,
    //       speed: 0.5,
    //       direction: Math.random() * Math.PI * 2,
    //       shootTimer: 0,
    //       hitpoints: 1,
    //       shootInterval: 150 // Adjust this value as needed
    //     };

    //     aliens.push(newAlien);
    //   }
    // }

    // function getAliensToSpawn(wave) {
    //   let booster = 0;
    //   if (currentMode == GameModes.NORMAL)
    //     booster++;
    //   else if (currentMode == GameModes.HARD)
    //     booster += 2;
    //   else if (currentMode == GameModes.HERO)
    //     booster += 3;

    //   if (wave > 50) return (parseInt(wave / 10)) + booster;
    //   if (wave == 50) return 4 + booster;
    //   if (wave == 45) return 4 + booster;
    //   if (wave == 40) return 3 + booster;
    //   if (wave == 35) return 3 + booster;
    //   if (wave == 30) return 1 + booster;
    //   if (wave == 25) return 2 + booster;
    //   if (wave == 15) return 1 + booster;
    //   if (wave == 10) return booster;
    //   if (wave == 5) return booster;
    //   // if (wave > 0) return 4;
    //   return 0;
    // }


    // function updateAliens() {
    //   if (!freezeEffect.active) {
    //     aliens.forEach(alien => {
    //       const dx = ship.x - alien.x;
    //       const dy = ship.y - alien.y;
    //       const angle = Math.atan2(dy, dx);

    //       alien.x += Math.cos(angle) * alien.speed;
    //       alien.y += Math.sin(angle) * alien.speed;

    //       alien.shootTimer++;
    //       if (alien.shootTimer >= alien.shootInterval) {
    //         alien.shootTimer = 0;
    //         shootAlienLaser(alien);
    //       }

    //       // Wrap the alien around the screen edges
    //       if (alien.x < 0) alien.x = canvas.width;
    //       else if (alien.x > canvas.width) alien.x = 0;
    //       if (alien.y < 0) alien.y = canvas.height;
    //       else if (alien.y > canvas.height) alien.y = 0;
    //     });
    //   }
    // }

    // function drawAliens() {
    //   aliens.forEach(alien => {
    //     ctx.save();
    //     ctx.translate(alien.x, alien.y);
    //     ctx.drawImage(alienImage, -alien.size / 2, -alien.size / 2, alien.size, alien.size);
    //     ctx.restore();
    //   });
    // }

    // function drawAliens() {
    //   aliens.forEach(alien => {
    //     ctx.save();
    //     ctx.translate(alien.x, alien.y);
    //     ctx.drawImage(alienImage, -alien.size / 2, -alien.size / 2, alien.size, alien.size);
    //     ctx.restore();
    //   });
    // }

    // function shootAlienLaser(alien) {
    //   const dx = ship.x - alien.x;
    //   const dy = ship.y - alien.y;
    //   const angle = Math.atan2(dy, dx);

    //   alienLasers.push({
    //     x: alien.x,
    //     y: alien.y,
    //     dx: Math.cos(angle) * alienLaserSpeed,
    //     dy: Math.sin(angle) * alienLaserSpeed
    //   });
    // }

    // function updateAlienLasers() {

    //   for (let i = alienLasers.length - 1; i >= 0; i--) {
    //     const laser = alienLasers[i];
    //     laser.x += laser.dx;
    //     laser.y += laser.dy;

    //     if (!invincible && isColliding(laser, ship)) {

    //       createExplosion(ship.x, ship.y);
    //       resetShip();
    //       lives--;
    //       playShipDestroyedSound();
    //       invincible = true;
    //       invincibilityTimer = invincibilityDuration;
    //       if (lives === 0) gameOver = true;
    //       return;
    //     }


    //     // Remove the laser if it goes off-screen
    //     if (laser.x < 0 || laser.x > canvas.width || laser.y < 0 || laser.y > canvas.height) {
    //       alienLasers.splice(i, 1);
    //     }
    //   }
    // }

    // function drawAlienLasers() {
    //   alienLasers.forEach(laser => {
    //     ctx.fillStyle = 'purple';
    //     ctx.beginPath();
    //     ctx.arc(laser.x, laser.y, alienLaserSize, 0, Math.PI * 2);
    //     ctx.fill();
    //   });
    // }


    // function shootAlienLaser(alien) {
    //   const dx = ship.x - alien.x;
    //   const dy = ship.y - alien.y;
    //   const angle = Math.atan2(dy, dx);

    //   alienLasers.push({
    //     x: alien.x,
    //     y: alien.y,
    //     dx: Math.cos(angle) * alienLaserSpeed,
    //     dy: Math.sin(angle) * alienLaserSpeed
    //   });
    // }


    // function drawAlienLasers() {
    //   alienLasers.forEach(laser => {
    //     ctx.fillStyle = 'purple';
    //     ctx.beginPath();
    //     ctx.arc(laser.x, laser.y, alienLaserSize, 0, Math.PI * 2);
    //     ctx.fill();
    //   });
    // }

    // function updateBossAlien() {
    //   if (!alien) return;
    //   if (!freezeEffect.active) {

    //     // Calculate direction towards the ship
    //     const dx = ship.x - alien.x;
    //     const dy = ship.y - alien.y;
    //     const angle = Math.atan2(dy, dx);

    //     // Update alien's position based on the new direction
    //     alien.x += Math.cos(angle) * alien.speed;
    //     alien.y += Math.sin(angle) * alien.speed;

    //     // Update alien's shooting timer
    //     alien.shootTimer++;
    //     if (alien.shootTimer >= alien.shootInterval) {
    //       alien.shootTimer = 0;
    //       shootBossAlienLaser();
    //     }

    //     // Wrap the alien around the screen edges
    //     if (alien.x < 0) alien.x = canvas.width;
    //     else if (alien.x > canvas.width) alien.x = 0;
    //     if (alien.y < 0) alien.y = canvas.height;
    //     else if (alien.y > canvas.height) alien.y = 0;
    //   }
    // }

    // function drawBossAlien() {
    //   if (!alien) return;
    //   // console.log("drawing alien");
    //   ctx.save();
    //   ctx.translate(alien.x, alien.y);
    //   ctx.drawImage(bossAlienImage, -alien.size / 2, -alien.size / 2, alien.size, alien.size);
    //   ctx.restore();
    // }

    // function shootBossAlienLaser() {
    //   if (!alien) return;
    //   // console.log("shooting laser");
    //   const dx = ship.x - alien.x;
    //   const dy = ship.y - alien.y;
    //   const angle = Math.atan2(dy, dx);

    //   alienLaser = {
    //     x: alien.x,
    //     y: alien.y,
    //     dx: Math.cos(angle) * alienLaserSpeed,
    //     dy: Math.sin(angle) * alienLaserSpeed
    //   };
    // }

    // function updateBossAlienLaser() {
    //   if (!alienLaser) return;

    //   alienLaser.x += alienLaser.dx;
    //   alienLaser.y += alienLaser.dy;

    //   if (!invincible && isColliding(alienLaser, ship)) {
    //     alienLaser = null;
    //     createExplosion(ship.x, ship.y);
    //     resetShip();
    //     lives--;
    //     playShipDestroyedSound();
    //     invincible = true;
    //     invincibilityTimer = invincibilityDuration;
    //     if (lives === 0) gameOver = true;
    //     return;
    //   }


    //   // Remove the laser if it goes off-screen
    //   if (
    //     alienLaser.x < 0 ||
    //     alienLaser.x > canvas.width ||
    //     alienLaser.y < 0 ||
    //     alienLaser.y > canvas.height
    //   ) {
    //     alienLaser = null;
    //   }
    // }

    // function drawBossAlienLaser() {
    //   if (!alienLaser) return;

    //   ctx.fillStyle = 'red';
    //   ctx.beginPath();
    //   ctx.arc(alienLaser.x, alienLaser.y, 6, 0, Math.PI * 2);
    //   ctx.fill();
    // }


    // function drawAsteroids() {
    //   for (let i = 0; i < asteroids.length; i++) {
    //     ctx.fillStyle = asteroids[i].color;
    //     ctx.beginPath();
    //     ctx.arc(asteroids[i].x, asteroids[i].y, asteroids[i].size, 0, Math.PI * 2);
    //     ctx.closePath();
    //     ctx.fill();
    //     // const asteroidImage = new Image();
    //     // asteroidImage.src = asteroids[i].image;
    //     // asteroidImage.src = "roids/8bitroid_2657.png";
    //     // console.log(asteroidImage.src);
    //     // if (asteroids[i].image == undefined || asteroids[i].image.length < 5)
    //     //   asteroidImage.src = "roids/8bitroid_2657.png";
    //     // else
    //     //   asteroidImage.src = asteroids[i].image;
    //     // ctx.save();
    //     // ctx.translate(asteroids[i].x, asteroids[i].y);
    //     // ctx.drawImage(asteroidImage, -asteroids[i].size, -asteroids[i].size, asteroids[i].size * 2, asteroids[i].size * 2);
    //     // ctx.restore();
    //   }
    // }

    // makes ship invisible
    function drawAsteroids() {
      // ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let i = 0; i < asteroids.length; i++) {
        ctx.strokeStyle = asteroids[i].color;
        ctx.lineWidth = asteroids[i].hitpoints + 1; // Set the line width to the asteroid's hitpoints
        ctx.beginPath();
        ctx.arc(asteroids[i].x, asteroids[i].y, asteroids[i].size, 0, Math.PI * 2);
        ctx.closePath();
        ctx.stroke(); // Draw only the outline
      }
    }




    // Function to create area damage
    function createAreaDamage(x, y, radius, damage = 1) {
      let totalDamage = 0;
      for (let i = asteroids.length - 1; i >= 0; i--) {
        let asteroid = asteroids[i];
        let dx = asteroid.x - x;
        let dy = asteroid.y - y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < radius) {
          let actualDamage = Math.min(damage + damageBooster, asteroid.hitpoints);
          asteroid.hitpoints -= actualDamage;
          totalDamage += actualDamage;

          if (asteroid.hitpoints <= 0) {
            createExplosion(asteroid.x, asteroid.y, asteroid.hitpoints, asteroid.image);
            asteroids.splice(i, 1);
          }

          coins += actualDamage * 15;
          increaseXP(actualDamage * 15);
          score += actualDamage * 50;
        }
      }
      return totalDamage;
    }


    function increaseXP(amount) {
      xp += amount;
      document.getElementById('xpBarContainer').style.display = 'block';

      updateXPBar();
      if (xp >= xpToNextLevel) {
        levelUp();
      }
    }

    function updateXPBar() {
      const xpBar = document.getElementById('xpBar');
      const xpPercentage = (xp / xpToNextLevel) * 100;
      xpBar.style.width = xpPercentage + '%';
    }


    function createExplosion(x, y, hitpoints = 1, asteroidImage = "") {
      const baseSize = 15; // Base size for explosions
      const sizeReductionFactor = 1.5; // Size reduction per hitpoint


      const randomSize = Math.max(5, baseSize - hitpoints * sizeReductionFactor);
      const randomAlphaDecay = Math.random() * 0.01 + 0.005; // Random alpha decay between 0.005 and 0.015
      const canvas = document.createElement('canvas');

      if (asteroidImage && asteroidImage.length > 5 && false) {

        const ctx = canvas.getContext('2d');
        canvas.width = baseSize;
        canvas.height = baseSize;
        ctx.drawImage(asteroidImage, 0, 0, baseSize, baseSize);
        const imageData = ctx.getImageData(0, 0, baseSize, baseSize);
        const pixels = imageData.data;

        // Create explosion particles using the extracted pixels
        for (let i = 0; i < pixels.length; i += 4) {
          const r = pixels[i];
          const g = pixels[i + 1];
          const b = pixels[i + 2];
          const a = pixels[i + 3];

          if (a > 0) {
            const particle = {
              x: x + (i / 4) % size - size / 2,
              y: y + Math.floor((i / 4) / size) - size / 2,
              color: `rgba(${r}, ${g}, ${b}, ${a})`,
              size: Math.random() * 3 + 1,
              speed: Math.random() * 3 + 1,
              direction: Math.random() * Math.PI * 2
            };
            explosions.push(particle);
          }
        }
      }



      let randomColor;
      if (hitpoints > 7) {
        randomColor = getRandomPurpleShade();
      } else if (hitpoints > 1) {
        randomColor = getRandomBlueShade();
      } else {
        randomColor = getRandomOrangeShade();
      }

      let explosion = {
        x: x,
        y: y,
        size: randomSize,
        alpha: 1,
        alphaDecay: randomAlphaDecay,
        color: randomColor
      };
      explosions.push(explosion);
      // drawPixelatedExplosion(x, y, randomSize + 10);
    }

    // Function to get a random shade of orange
    function getRandomOrangeShade() {
      const shades = ['#FF4500', '#FF6347', '#FF8C00', '#FFA500', '#FF7F50'];
      return shades[Math.floor(Math.random() * shades.length)];
    }

    function getRandomBlueShade() {
      const shades = ['#1E90FF', '#00BFFF', '#87CEFA', '#4682B4', '#5F9EA0'];
      return shades[Math.floor(Math.random() * shades.length)];
    }

    function getRandomPurpleShade() {
      const shades = ['#800080', '#8B008B', '#9370DB', '#9400D3', '#9932CC', '#BA55D3', '#DA70D6', '#DDA0DD', '#EE82EE', '#FF00FF'];
      return shades[Math.floor(Math.random() * shades.length)];
    }
    // Function to get a random shade of red
    function getRandomRedShade() {
      const shades = ['#FF0000', '#DC143C', '#B22222', '#FF6347', '#FF4500'];
      return shades[Math.floor(Math.random() * shades.length)];
    }

    // Update explosions with random alpha decay
    function updateExplosions() {
      for (let i = 0; i < explosions.length; i++) {
        explosions[i].size += 1;
        explosions[i].alpha -= explosions[i].alphaDecay;
        if (explosions[i].alpha <= 0) {
          explosions.splice(i, 1);
          i--;
        }
      }
    }

    // Draw explosions with random colors
    function drawExplosions() {
      for (let i = 0; i < explosions.length; i++) {
        ctx.save();
        ctx.globalAlpha = explosions[i].alpha;
        ctx.beginPath();
        ctx.arc(explosions[i].x, explosions[i].y, explosions[i].size, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fillStyle = explosions[i].color;
        ctx.fill();
        ctx.restore();
      }
    }

    // Reset ship position
    function resetShip() {
      ship.x = canvas.width / 2;
      ship.y = canvas.height / 2;
      ship.velocityX = 0;
      ship.velocityY = 0;
      ship.speed = 0;
    }

    function buySuperWeapon(weapon) {
      switch (weapon) {
        case 'missile':
          if (coins >= 200) {
            coins -= 200;
            superWeapons.missile++;
            updateMarketplaceDisplay();
          }
          break;
        case 'laser':
          if (coins >= 300) {
            coins -= 300;
            superWeapons.laser++;
            updateMarketplaceDisplay();
          }
          break;
        case 'bomb':
          if (coins >= 400) {
            coins -= 400;
            superWeapons.bomb++;
            updateMarketplaceDisplay();
          }
          break;
      }
    }

    let explosiveRockets = [];

    function fireExplosiveRocket() {
      if (explosiveRocket.timer === 0) {
        const angle = ship.rotation * Math.PI / 180;
        const rocket = {
          x: ship.x + Math.sin(angle) * 20,
          y: ship.y - Math.cos(angle) * 20,
          angle: angle,
          speed: explosiveRocket.speed,
          damage: explosiveRocket.damage,
          radius: explosiveRocket.radius,
          distance: 0 // Add distance property to track rocket's travel distance
        };
        explosiveRockets.push(rocket);
        explosiveRocket.timer = explosiveRocket.cooldown;
      }
    }

    function updateExplosiveRockets() {
      for (let i = explosiveRockets.length - 1; i >= 0; i--) {
        const rocket = explosiveRockets[i];
        rocket.x += Math.sin(rocket.angle) * rocket.speed;
        rocket.y -= Math.cos(rocket.angle) * rocket.speed;
        rocket.distance += rocket.speed; // Update the rocket's travel distance

        if (rocket.distance >= 200) { // Check if the rocket has traveled a certain distance
          createExplosion(rocket.x, rocket.y, 0); // Create an explosion effect at the rocket's position
          applyExplosiveDamage(rocket); // Apply area damage to asteroids within the explosion radius
          explosiveRockets.splice(i, 1); // Remove the rocket from the array
          continue;
        }

        if (rocket.x < 0 || rocket.x > canvas.width || rocket.y < 0 || rocket.y > canvas.height) {
          explosiveRockets.splice(i, 1);
        }
      }
    }

    function applyExplosiveDamage(rocket) {
      for (let j = asteroids.length - 1; j >= 0; j--) {
        const asteroid = asteroids[j];
        const dx = rocket.x - asteroid.x;
        const dy = rocket.y - asteroid.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < rocket.radius) {
          const damage = Math.min(rocket.damage, asteroid.hitpoints);
          asteroid.hitpoints -= damage;
          damageReport.explosiveRocket += damage;

          if (asteroid.hitpoints <= 0) {
            createExplosion(asteroid.x, asteroid.y, asteroid.hitpoints, asteroid.image);
            asteroids.splice(j, 1);
          }
        }
      }
    }



    // Function to update marketplace display
    function updateMarketplaceDisplay() {
      coinsDisplay.textContent = coins;
      laserLevelDisplay.textContent = ship.laserLevel;
      // accelerationLevelDisplay.textContent = ship.accelerationLevel;
      document.getElementById('laserCooldownLevel').textContent = ship.laserCooldownLevel;
      document.getElementById('explosiveLaserLevel').textContent = ship.explosiveLaserLevel;
      document.getElementById('turretRangeLevel').textContent = turretUpgrades.range;
      document.getElementById('turretFireRateLevel').textContent = turretUpgrades.fireRate;
      document.getElementById('turretDamageLevel').textContent = turretUpgrades.damage;
      rotationSpeedLevelDisplay.textContent = ship.rotationSpeedLevel;
      maxBulletsLevelDisplay.textContent = ship.maxBulletsLevel;
      droneSpeedLevelDisplay.textContent = droneUpgrades.speed;
      // droneLaserSpeedLevelDisplay.textContent = droneUpgrades.laserSpeed;
      droneLaserIntervalLevelDisplay.textContent = droneUpgrades.laserInterval;
    }

    function activateMissile() {
      // Find the nearest asteroid to the ship
      let nearestAsteroid = null;
      let nearestDistance = Infinity;
      for (let i = 0; i < asteroids.length; i++) {
        let dx = ship.x - asteroids[i].x;
        let dy = ship.y - asteroids[i].y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < nearestDistance) {
          nearestAsteroid = asteroids[i];
          nearestDistance = distance;
        }
      }

      if (nearestAsteroid) {
        // Create an explosion at the nearest asteroid's position
        createExplosion(nearestAsteroid.x, nearestAsteroid.y);
        // Remove the nearest asteroid
        let index = asteroids.indexOf(nearestAsteroid);
        asteroids.splice(index, 1);
        score += 50;
      }
    }

    function activateLaserBeam() {
      // Destroy all asteroids in a straight line in front of the ship
      let angle = ship.rotation * Math.PI / 180;
      let startX = ship.x;
      let startY = ship.y;
      let endX = ship.x + canvas.width * Math.sin(angle);
      let endY = ship.y - canvas.width * Math.cos(angle);

      for (let i = asteroids.length - 1; i >= 0; i--) {
        if (isPointOnLine(asteroids[i].x, asteroids[i].y, startX, startY, endX, endY)) {
          createExplosion(asteroids[i].x, asteroids[i].y);
          asteroids.splice(i, 1);
          score += 50;
        }
      }
    }

    function isPointOnLine(px, py, startX, startY, endX, endY) {
      let threshold = 10; // Adjust this value to control the thickness of the laser beam
      let distance = Math.abs((endY - startY) * px - (endX - startX) * py + endX * startY - endY * startX) / Math.sqrt(Math.pow(endY - startY, 2) + Math.pow(endX - startX, 2));
      return distance <= threshold;
    }

    function activateBomb() {
      // Destroy all asteroids within a certain radius of the ship
      let bombRadius = 100; // Adjust this value to control the size of the bomb explosion
      for (let i = asteroids.length - 1; i >= 0; i--) {
        let dx = ship.x - asteroids[i].x;
        let dy = ship.y - asteroids[i].y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        if (distance <= bombRadius) {
          createExplosion(asteroids[i].x, asteroids[i].y);
          asteroids.splice(i, 1);
          score += 50;
        }
      }
    }

    function activateFlamethrower() {
      flamethrower.active = true;
      flamethrower.timer = flamethrower.cooldown;
    }


    function updateFlamethrower() {
      if (flamethrower.active) {
        // Define the area of effect for the flamethrower
        let flameRange = flamethrower.range;
        let flameWidth = 20;

        // Calculate the endpoint of the flamethrower
        let endX = ship.x + flameRange * Math.sin(ship.rotation * Math.PI / 180);
        let endY = ship.y - flameRange * Math.cos(ship.rotation * Math.PI / 180);

        // Check for collisions with asteroids
        for (let i = asteroids.length - 1; i >= 0; i--) {
          let asteroid = asteroids[i];
          let dx = asteroid.x - ship.x;
          let dy = asteroid.y - ship.y;
          let distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < flameRange && Math.abs(dx * Math.cos(ship.rotation * Math.PI / 180) + dy * Math.sin(ship.rotation * Math.PI / 180)) < flameWidth / 2) {
            asteroid.isOnFire = true; // Set the asteroid on fire
            asteroid.fireTimer = 0; // Reset the fire timer
          }
        }

        // Draw the flamethrower
        ctx.save();
        ctx.strokeStyle = 'orange';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(ship.x, ship.y);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        ctx.restore();

        flamethrower.active = false;
      }
    }

    function updateAsteroidFire() {
      for (let i = asteroids.length - 1; i >= 0; i--) {
        let asteroid = asteroids[i];
        if (asteroid.isOnFire) {
          asteroid.fireTimer++;
          if (asteroid.fireTimer >= 60) { // Damage applied every second (assuming 60 FPS)
            asteroid.hitpoints -= flamethrower.damagePerSecond;
            damageReport.flamethrower += flamethrower.damagePerSecond;
            asteroid.fireTimer = 0; // Reset the fire timer
          }

          asteroid.color = 'darkred'; // Change the asteroid color to dark red

          if (asteroid.hitpoints <= 0) {
            createExplosion(asteroid.x, asteroid.y, asteroid.hitpoints, asteroid.image);
            asteroids.splice(i, 1);
          }
        } else {
          asteroid.color = 'gray'; // Reset the asteroid color if not on fire
        }
      }
    }




    function activateSonicBlast() {
      if (sonicBlast.timer === 0) {
        sonicBlast.waves.push({
          x: ship.x,
          y: ship.y,
          radius: 0,
          hitAsteroids: [], // Array to store the IDs of hit asteroids
        });
        sonicBlast.timer = sonicBlast.cooldown;
      }
    }

    function activateChainLightning() {
      if (chainLightning.timer === 0) {
        let target = findNearestAsteroid();
        if (target) {
          fireChainLightning(target, chainLightning.bounces);
          chainLightning.timer = chainLightning.cooldown;
        }
      }
    }

    function fireChainLightning(target, bounces) {
      if (bounces <= 0 || !target) return;

      let damage = chainLightning.damage;
      let actualDamage = Math.min(damage + damageBooster, target.hitpoints);
      target.hitpoints -= actualDamage;
      damageReport.chainlightning += actualDamage;

      if (target.hitpoints <= 0) {
        createExplosion(target.x, target.y, target.hitpoints, target.image);
        let index = asteroids.indexOf(target);
        asteroids.splice(index, 1);
      }

      drawChainLightning(ship, target);

      let nextTarget = findNearestAsteroidInRange(target, chainLightning.range);
      if (nextTarget) {
        drawChainLightning(target, nextTarget);
        fireChainLightning(nextTarget, bounces - 1);
      }
    }

    function drawChainLightning(source, target) {
      ctx.beginPath();
      ctx.moveTo(source.x, source.y);
      ctx.lineTo(target.x, target.y);
      ctx.strokeStyle = 'blue';
      ctx.lineWidth = 2;
      ctx.stroke();
    }



    function activateDeathRay() {
      if (deathRay.timer === 0) {
        deathRayActive = true;
        playRandomDeathRaySound();
        deathRay.timer = deathRay.cooldown;
      }
    }

    function activateFreezeEffect() {
      if (freezeEffect.timer === 0) {
        freezeEffect.active = true;
        playFreezeSound();
        freezeEffect.remainingDuration = freezeEffect.duration;
        freezeEffect.timer = freezeEffect.cooldown;
      }
    }


    function updateFreezeEffect() {
      if (freezeEffect.timer > 0) {
        freezeEffect.timer--;
      }

      if (freezeEffect.active) {
        freezeEffect.remainingDuration--;

        if (freezeEffect.remainingDuration <= 0) {
          freezeEffect.active = false;
        }
      }
    }


    function fireAcidBomb() {
      if (acidBomb.timer === 0) {
        let angle = Math.random() * 2 * Math.PI; // Random direction
        let bomb = {
          x: ship.x,
          y: ship.y,
          radius: acidBomb.size,
          duration: acidBomb.duration,
          dx: Math.cos(angle),
          dy: Math.sin(angle),
          distanceTraveled: 0
        };
        acidBomb.activeBombs.push(bomb);
        acidBomb.timer = acidBomb.cooldown;
      }
    }

    function updateAcidBombs() {
      for (let i = acidBomb.activeBombs.length - 1; i >= 0; i--) {
        let bomb = acidBomb.activeBombs[i];
        bomb.x += bomb.dx * 2;
        bomb.y += bomb.dy * 2;
        bomb.distanceTraveled += 2;

        if (bomb.distanceTraveled >= 150) {
          createAcidExplosion(bomb.x, bomb.y, bomb.radius, bomb.duration);
          acidBomb.activeBombs.splice(i, 1);
        }
      }
    }

    function createAcidExplosion(x, y, radius, duration) {
      createExplosion(x, y, 0); // Create visual explosion effect
      playRandomAcidBombSound();
      let acidArea = {
        x: x,
        y: y,
        radius: radius,
        duration: duration
      };
      acidBomb.activeAreas.push(acidArea);
    }

    function updateAcidAreas() {
      for (let i = acidBomb.activeAreas.length - 1; i >= 0; i--) {
        let area = acidBomb.activeAreas[i];
        area.duration--;

        for (let j = asteroids.length - 1; j >= 0; j--) {
          let asteroid = asteroids[j];
          let dx = asteroid.x - area.x;
          let dy = asteroid.y - area.y;
          let distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < area.radius) {
            let actualDamage = Math.min(acidBomb.damagePerSecond + damageBooster, asteroid.hitpoints);
            asteroid.hitpoints -= actualDamage;
            damageReport.acid += actualDamage;

            if (asteroid.hitpoints <= 0) {
              createExplosion(asteroid.x, asteroid.y, asteroid.hitpoints, asteroid.image);
              asteroids.splice(j, 1);
            }
          }
        }

        if (area.duration <= 0) {
          acidBomb.activeAreas.splice(i, 1);
        }
      }
    }


    function drawAcidAreas() {
      ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
      for (let i = 0; i < acidBomb.activeAreas.length; i++) {
        let area = acidBomb.activeAreas[i];
        ctx.beginPath();
        ctx.arc(area.x, area.y, area.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }


    function updateDeathRay() {
      if (deathRayActive) {
        // Define the area of effect for the Death Ray
        let rayLength = deathRay.length;
        let rayWidth = deathRay.width;

        // Calculate the angle for the endpoints to create a fan effect
        let spreadAngle = Math.PI / (15 - deathRayUpgrades.width); // Adjust the spread angle for a wider fan effect

        let endX = ship.x + rayLength * Math.sin(ship.rotation * Math.PI / 180);
        let endY = ship.y - rayLength * Math.cos(ship.rotation * Math.PI / 180);

        let leftEndX = ship.x + rayLength * Math.sin((ship.rotation * Math.PI / 180) - spreadAngle);
        let leftEndY = ship.y - rayLength * Math.cos((ship.rotation * Math.PI / 180) - spreadAngle);

        let rightEndX = ship.x + rayLength * Math.sin((ship.rotation * Math.PI / 180) + spreadAngle);
        let rightEndY = ship.y - rayLength * Math.cos((ship.rotation * Math.PI / 180) + spreadAngle);

        // Check for collisions with asteroids
        for (let i = asteroids.length - 1; i >= 0; i--) {
          let asteroid = asteroids[i];
          let dx = asteroid.x - ship.x;
          let dy = asteroid.y - ship.y;
          let distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < rayLength && Math.abs(dx * Math.cos(ship.rotation * Math.PI / 180) + dy * Math.sin(ship.rotation * Math.PI / 180)) < rayWidth / 2) {
            createExplosion(asteroid.x, asteroid.y, 1, asteroid.image);
            asteroids.splice(i, 1);
            damageReport.deathRay += asteroid.hitpoints;
            increaseXP(asteroid.hitpoints * 20);

          }
        }

        for (let j = aliens.length - 1; j >= 0; j--) {
          const alien = aliens[j];
          let dx = alien.x - ship.x;
          let dy = alien.y - ship.y;
          let distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < rayLength && Math.abs(dx * Math.cos(ship.rotation * Math.PI / 180) + dy * Math.sin(ship.rotation * Math.PI / 180)) < rayWidth / 2) {
            createExplosion(alien.x, alien.y, 12);
            aliens.splice(j, 1);
            damageReport.deathRay += 20;
            increaseXP(200);

          }
        }


        // Draw the Death Ray as a triangle
        ctx.save();
        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
        ctx.beginPath();
        ctx.moveTo(ship.x, ship.y);
        ctx.lineTo(leftEndX, leftEndY);
        ctx.lineTo(rightEndX, rightEndY);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        deathRayActive = false;
      }

      if (deathRay.timer > 0) {
        deathRay.timer--;
      }
    }


    let keys = {};
    let isPaused = false;

    function handleKeyDown(event) {
      keys[event.key] = true;

      if (event.key === 'i' || event.key === 'I') {
        // console.log("toggle1");
        toggleWeaponInfo();
      } else if (event.key === 'p' || event.key === 'P') {
        if (isPaused) {

          gameLoop = setInterval(update, 1000 / 60); // Resume game loop
          isPaused = false;

        } else if (event.key === 'v' || event.key === 'V') {

          toggleVolumeScreen();

        }
        else {

          clearInterval(gameLoop);
          isPaused = true;

        }
        // } 

        // else if (event.key === 'b') {
        //   if (marketplace.style.display === 'block') {
        //     exitMarketplace();
        //   } else {
        //     pauseGameForMarketplace();
        //   }

      } else if (event.key === 'm') {
        toggleMusic();
      } else if (event.key === 'n') {
        toggleSound();
      }
    }

    function handleKeyUp(event) {
      keys[event.key] = false;
    }

    let toggleOff = false;
    let toggleSoundOff = false;

    function toggleMusic() {
      if (!toggleOff)
        toggleOff = true;
      backgroundMusic.pause();

      if (isMusicPlaying) {
        backgroundMusic.pause();
      } else {
        backgroundMusic.play();
      }
      isMusicPlaying = !isMusicPlaying;
    }

    function toggleSound() {
      if (!toggleSoundOff)
        toggleSoundOff = true;
      else
        toggleSoundOff = false;

    }






    window.addEventListener('resize', resizeCanvas);

    joystick.addEventListener('touchstart', (e) => {
      isTouchingJoystick = true;
      joystickStartX = e.touches[0].clientX;
      joystickStartY = e.touches[0].clientY;
    });

    canvas.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        const touch = e.touches[0];
        const touchX = touch.clientX;

        const canvasWidth = canvas.width;
        const partWidth = canvasWidth / 5; // Divide the canvas width into 5 parts

        if (touchX < partWidth) {
          // Hard left turn
          ship.rotation -= (ship.rotationSpeed * 3);
        } else if (touchX < partWidth * 2) {
          // Soft left turn
          ship.rotation -= ship.rotationSpeed;
        } else if (touchX < partWidth * 3) {
          // Acceleration
          if (ship.speed < ship.maxSpeed) {
            ship.speed += (ship.acceleration * 7);
            ship.velocityX += ship.acceleration * Math.sin(angle);
            ship.velocityY -= ship.acceleration * Math.cos(angle);

          }
        } else if (touchX < partWidth * 4) {
          // Soft right turn
          ship.rotation += ship.rotationSpeed;
        } else {
          // Hard right turn
          ship.rotation += (ship.rotationSpeed * 3);
        }
      }
    });

    joystick.addEventListener('touchmove', (e) => {
      if (isTouchingJoystick) {
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        const deltaX = touchX - joystickStartX;
        const deltaY = touchY - joystickStartY;

        // Calculate angle and distance from the center
        const angle = Math.atan2(deltaY, deltaX);
        const distance = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), 50); // Limit the joystick handle movement

        // Update joystick handle position
        joystickHandle.style.transform = `translate(${distance * Math.cos(angle)}px, ${distance * Math.sin(angle)}px)`;

        // Update ship rotation and speed based on joystick movement
        ship.rotation = angle * (180 / Math.PI); // Convert radians to degrees
        ship.speed = Math.min(distance / 20, ship.maxSpeed); // Adjust speed based on distance, ensure it doesn't exceed maxSpeed

        e.preventDefault();
      }
    });

    joystick.addEventListener('touchend', () => {
      isTouchingJoystick = false;
      ship.speed = 0;
      joystickHandle.style.transform = 'translate(-50%, -50%)'; // Reset joystick handle position
    });

    restartButton.addEventListener('click', () => {
      restartButton.style.display = 'none';
      startScreen.style.display = 'block';

      let count = countTechnologies();
      const technologiesCountElement = document.getElementById('technologiesCount');
      technologiesCountElement.textContent = `You have unlocked ${count} of 22 technologies`;
      document.getElementById('technologiesCount').style.display = 'show';
      document.getElementById('shipType').style.display = 'show';

      lives = 3;
      score = 0;
      wave = 1;
      asteroidsKilled = 0;
      aliensKilled = 0;
      fourthUpgradeUnlocked = false;

      // Reset coins and XP
      coins = 0;
      level = 1;
      xpToNextLevel = 300;
      xp = 0;
      updateXPBar();

      // Reset asteroids and drones
      asteroids = [];
      drones = [];
      aliens = [];
      alien = null;
      superbossAlien = null;
      alienLasers = [];
      droppedGems = [];

      // Reset turret upgrades
      turret.bought = false;
      // Reset active weapon classes
      activeWeaponClasses = [];


      level = 1;
      xp = 0;

      acidBomb = {
        cooldown: 300,
        timer: 0,
        duration: 300, // Duration the acid effect lasts (5 seconds at 60 FPS)
        damagePerSecond: 1,
        size: 50,
        activeBombs: [],
        activeAreas: []
      };

      acidBombUpgrades = {
        duration: 1,
        cooldown: 1,
        size: 1
      };

      boomerang = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        size: 10,
        speed: 2,
        damage: 1,
        dx: 3,
        dy: 3,
        active: false
      };

      boomerangUpgrades = {
        speed: 1,
        damage: 1
      };

      homingMissile = {
        cooldown: 300,
        timer: 0,
        speed: 2,
        damage: 5,
        activeMissiles: []
      };

      homingMissileUpgrades = {
        speed: 1,
        damage: 1,
        cooldown: 1
      };

      freezeEffect = {
        cooldown: 600, // Cooldown period for freeze effect (10 seconds at 60 FPS)
        timer: 0,
        duration: 300, // Duration the freeze effect lasts (5 seconds at 60 FPS)
        active: false,
        remainingDuration: 0
      };

      freezeEffectUpgrades = {
        duration: 1,
        cooldown: 1
      };

      damageReport = {
        lasers: 0,
        explosive: 0,
        drones: 0,
        turret: 0,
        sonicBlast: 0,
        bomberDrones: 0,
        deathRay: 0,
        acid: 0,
        freeze: 0,
        boomerang: 0,
        homing: 0

      };


      deathRay = {
        length: 1000,
        width: 50,
        cooldown: 300,
        timer: 0
      };

      deathRayActive = false;

      deathRayUpgrades = {
        length: 1,
        width: 1,
        cooldown: 1
      };



      ship = {
        x: canvas.width / 2,
        y: canvas.height - 50,
        size: 20,
        speed: 0,
        acceleration: 0.15,
        deceleration: 0.96,
        maxSpeed: 5,
        rotation: 0,
        rotationSpeed: 2.2,
        lasers: [],
        velocityX: 0,
        velocityY: 0,
        laserLevel: 1,
        accelerationLevel: 1,
        rotationSpeedLevel: 1,
        maxBulletsLevel: 1,
        explosiveLaserLevel: 0,
        laserCooldown: 30,
        laserTimer: 0,
        laserCooldownLevel: 1,

      };

      drone = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        size: 10,
        speed: 0.0001,
        direction: Math.random() * Math.PI * 2,
        lasers: [],
        laserSpeed: 3,
        laserInterval: 80, // Fire lasers every 120 frames (2 second)
        laserTimer: 0
      };

      turret = {
        x: 0,
        y: 0,
        size: 10,
        rotationSpeed: 2,
        fireInterval: 120,
        fireTimer: 0,
        range: 400,
        damage: 3,
        color: 'cyan',
        lasers: [] // Initialize the turret's lasers array
      };

      turretUpgrades = {
        range: 1,
        fireRate: 1,
        damage: 1
      };

      sonicBlast = {
        cooldown: 300, // Cooldown time in frames (5 seconds at 60 FPS)
        timer: 0, // Current cooldown timer
        range: 120, // Range of the sonic blast
        speed: 2, // Speed of the sonic blast wave
        damage: 1, // Damage dealt by the sonic blast
        waves: [], // Array to store the active sonic blast waves
        rangeLevel: 1,
        damageLevel: 1,
        cooldownLevel: 1

      };

      // Reset game state
      gameOver = false;
      invincible = true;
      invincibilityTimer = invincibilityDuration;
      document.getElementById('leaderboard-container').style.display = 'none';

      // Reset spawn variables
      spawnTimer = spawnCooldown;
      chanceForSmallAsteroid = 3;
      chanceForVerySmallAsteroid = 1;
      chanceForHardenedAsteroid = 5;
      chanceForVeryHardenedAsteroid = 2;

      // Reset ship position
      // resetShip();

      bomberDrones = [];


      // bomberDrones = [];
      bomberDroneUpgrades = {
        speed: 1,
        bombRadiusLevel: 1,
        bombRadius: 50,
        bombDamage: 2
      };

      chainLightning = {
        cooldown: 300, // Cooldown time in frames
        timer: 0, // Current cooldown timer
        range: 200, // Range of the chain lightning
        damage: 5, // Damage dealt per hit
        bounces: 2, // Number of bounces
        active: false // Flag to track if the chain lightning is active
      };

      chainLightningUpgrades = {
        range: 1,
        damage: 1,
        bounces: 1,
        cooldown: 1
      };


      // Start a new game
      // createAsteroids();
      // startGame();
    });

    document.addEventListener('keydown', function (event) {
      if (document.getElementById('levelUpModal').style.display === 'block') {
        if (event.key === '1') {
          selectUpgrade(1);
        } else if (event.key === '2') {
          selectUpgrade(2);
        } else if (event.key === '3') {
          selectUpgrade(3);
        }
      }
    });

    // Start the game
    // startGame();


    // document.addEventListener('DOMContentLoaded', () => {
    //   // loadUnlocks();
    //   populateAchievements();
    //   if (isMobile()) {
    //     document.getElementById('joystick').style.display = 'block';
    //     document.getElementById('startScreen').style.display = 'flex';
    //   } else {
    //     // startGame();
    //   }
    // });


    const weapons = [
      {
        name: 'Basic Laser',
        description: 'Standard weapon. Fires straight lasers.',
        icon: 'icons/Basiclaser.svg'
      },
      {
        name: 'Explosive Laser',
        description: 'Lasers explode on impact, causing area damage.',
        icon: 'icons/Explosivelaser.svg'
      },
      {
        name: 'Laser Drone',
        description: 'Drone that flies around you shooting randomly.',
        icon: 'icons/laserdrone.png'
      },
      {
        name: 'Bomber Drone',
        description: 'Drone that leaves protective mines that explode with area damage when an asteroid gets nearby.',
        icon: 'icons/Bomberdrone.svg'
      },
      {
        name: 'Acid Bomb',
        description: 'Releases acid that deals damage over time in an area.',
        icon: 'icons/Acidbomb.svg'
      },
      {
        name: 'Sonic Blast',
        description: 'Creates a wave that damages all enemies in its path.',
        icon: 'icons/Sonicray.svg'
      },
      {
        name: 'Death Ray',
        description: 'Fire a beam that melts and instakills everything in its path.',
        icon: 'icons/Deathray.svg'
      },
      {
        name: 'Boomerang',
        description: 'A boomerang that bounces around the level.',
        icon: 'icons/Boomerang.svg'
      },
      {
        name: 'Freeze Ray',
        description: 'Freezes enemies in place for a short duration.',
        icon: 'icons/Freeze.svg'
      },
      {
        name: 'Nano Swarm',
        description: 'A swarm of nanobots that seek and destroy enemies.',
        icon: 'icons/nanodrone.png'
      },
      {
        name: 'Turret',
        description: 'Deploys a turret that automatically shoots at enemies.',
        icon: 'icons/Autocannon.svg'
      },
      {
        name: 'Flamethrower',
        description: 'Shoots a continuous stream of fire.',
        icon: 'icons/flamethrower.png'
      },
      {
        name: 'Chain Lightning',
        description: 'Fires a lightning bolt that bounces between asteroids.',
        icon: 'icons/chainlightning.png'
      },
      {
        name: 'Explosive Rocket',
        description: 'Fires a slow-moving rocket that causes explosive AoE damage on impact.',
        icon: 'icons/explosive-rocket.png'
      }




    ];

    function toggleWeaponInfo() {
      const weaponInfoDiv = document.getElementById('weaponInfo');

      // console.log(weaponInfoDiv);
      weaponInfoDiv.style.display = weaponInfoDiv.style.display === 'none' ? 'block' : 'none';
      // console.log("toggle2");
      if (weaponInfoDiv.style.display === 'none') {
        clearInterval(gameLoop);
        gameLoop = setInterval(update, 1000 / 60);
      } else {
        clearInterval(gameLoop);

      }

      // Won't place nicely together with above
      // if (isPaused) {

      //   gameLoop = setInterval(update, 1000 / 60); // Resume game loop
      //   isPaused = false;

      // } else {

      //   clearInterval(gameLoop);
      //   isPaused = true;

      // }


    }

    function loadWeaponInfo() {
      const weaponsContainer = document.getElementById('weaponsContainer');
      weaponsContainer.innerHTML = '';
      weapons.forEach(weapon => {
        const weaponDiv = document.createElement('div');
        weaponDiv.className = 'weapon';
        weaponDiv.innerHTML = `
          <img src="${weapon.icon}" alt="${weapon.name}">
          <p><strong>${weapon.name}</strong></p>
          <p>${weapon.description}</p>
        `;
        weaponsContainer.appendChild(weaponDiv);
      });
    }



    function populateAchievements() {
      const achievementsList = document.getElementById('achievementsList');
      achievementsList.innerHTML = '';

      document.getElementById('normalButton').disabled = !Achievements.complete_easy_mode.reached;
      document.getElementById('hardButton').disabled = !Achievements.complete_normal_mode.reached;
      document.getElementById('heroButton').disabled = !Achievements.complete_hard_mode.reached;


      document.getElementById('meteorEasyButton').disabled = !Achievements.complete_normal_mode.reached;
      document.getElementById('meteorNormalButton').disabled = !Achievements.complete_meteor_easy_mode.reached;
      document.getElementById('meteorHardButton').disabled = !Achievements.complete_meteor_normal_mode.reached;
      document.getElementById('meteorHeroButton').disabled = !Achievements.complete_meteor_hard_mode.reached;

      document.getElementById('planetEasyButton').disabled = !Achievements.complete_meteor_normal_mode.reached;
      document.getElementById('planetNormalButton').disabled = !Achievements.complete_planet_easy_mode.reached;
      document.getElementById('planetHardButton').disabled = !Achievements.complete_planet_normal_mode.reached;
      document.getElementById('planetHeroButton').disabled = !Achievements.complete_planet_hero_mode.reached;

      for (const key in Achievements) {
        if (Achievements.hasOwnProperty(key)) {
          const achievement = Achievements[key];
          const achieved = achievement.reached || (achievement.damage && achievement.damage >= achievement.required);

          const achievementElement = document.createElement('div');
          achievementElement.classList.add('achievement');
          achievementElement.style.opacity = achieved ? '1' : '0.5';

          const icon = document.createElement('img');
          icon.src = achievement.icon;
          icon.alt = achievement.description;
          achievementElement.appendChild(icon);
          const description = document.createElement('span');
          description.textContent = achievement.description;
          achievementElement.appendChild(description);

          achievementsList.appendChild(achievementElement);
        }
      }

      let count = countTechnologies();
      const technologiesCountElement = document.getElementById('technologiesCount');
      technologiesCountElement.textContent = `${count} of 20 technologies unlocked`;

    }


    const Achievements = {
      reach_wave_2: { reached: false, icon: 'achievements/whitehat.png', description: 'Reach Wave 2' },
      reach_wave_5: { reached: false, icon: 'achievements/whitehat.png', description: 'Reach Wave 5' },
      // reach_wave_57: { reached: false, icon: 'achievements/whitehat.png', description: 'Reach Wave 7' },
      reach_wave_10: { reached: false, icon: 'achievements/angelcapitan.png', description: 'Reach Wave 10. Unlock Sonic Blast.' },
      // reach_wave_15: { reached: false, icon: 'achievements/insanecat.png', description: 'Reach Wave 15' },
      reach_wave_20: { reached: false, icon: 'achievements/keroaccat.png', description: 'Reach Wave 20. Unlock Boomerang.' },
      // reach_wave_25: { reached: false, icon: 'achievements/onthemoon.png', description: 'Reach Wave 25' },
      destroy_100_asteroids: { reached: false, icon: 'achievements/speedy.png', description: 'Destroy 100 Asteroids in One Game. Unlock Drone.' },
      // destroy_500_asteroids: { reached: false, icon: 'achievements/_5973.png', description: 'Destroy 500 Asteroids in One Game' },
      complete_easy_mode: { reached: false, icon: 'achievements/whitehat.png', description: 'Complete Easy Mode.' },
      complete_normal_mode: { reached: false, icon: 'achievements/insanecat.png', description: 'Normal Mode. Unlock Acid Bomb.' },

      acid_bomb_damage: { reached: false, damage: 0, required: 10000, icon: 'achievements/acid.png', description: 'Deal 10,000 Damage with Acid Bomb. Unlock Flamethrower.' },
      laser_damage: { reached: false, damage: 0, required: 2500, icon: 'achievements/deathray2.png', description: 'Deal 2,500 Damage with Laser. Unlock Explosive Laser.' },
      drone_damage: { reached: false, damage: 0, required: 5000, icon: 'achievements/storm_drone.png', description: 'Deal 5,000 Damage with Drone. Unlock Drone Army.' },
      explosive_laser_damage: { reached: false, damage: 0, required: 10000, icon: 'achievements/explosive.png', description: 'Deal 10,000 Damage with Explosive Laser' },
      death_ray_damage: { reached: false, damage: 0, required: 10000, icon: 'achievements/deathray.png', description: 'Deal 10,000 Damage with Death Ray. Unlock Extra Choice.' },
      no_lives_lost: { reached: false, icon: 'achievements/orpheus.png', description: 'Survived with No Lives Lost. Unlock Nano Swarm.' },
      complete_hard_mode: { reached: false, icon: 'achievements/explosion.png', description: 'Hard Mode. Unlock Damage Boost.' },
      complete_hero_mode: { reached: false, icon: 'achievements/cyberpunk.png', description: 'Hero Mode. Unlock Extra Life.' },
      kill_5_aliens: { reached: false, icon: 'achievements/aliensign.png', description: 'Kill 5 Aliens. Unlock Death Ray.' },
      kill_15_aliens: { reached: false, icon: 'achievements/aliensign.png', description: 'Kill 15 Aliens. Unlock Chain Lightning.' },
      complete_meteor_easy_mode: { reached: false, icon: 'achievements/meteor_one.png', description: 'Shower Easy Mode.' },
      complete_meteor_normal_mode: { reached: false, icon: 'achievements/meteor_acid.png', description: 'Shower Normal Mode. Unlock Double Turret.' },
      complete_meteor_hard_mode: { reached: false, icon: 'achievements/meteor_small.png', description: 'Shower Hard Mode. Unlock Starhawk.' },
      complete_meteor_hero_mode: { reached: false, icon: 'achievements/death_meteor.png', description: 'Shower Hero Mode' },
      complete_planet_easy_mode: { reached: false, icon: 'achievements/planet_medium.png', description: 'Planet Easy Mode.' },
      complete_planet_normal_mode: { reached: false, icon: 'achievements/storm_medium.png', description: 'Planet Normal Mode. Unlock Triple Turret.' },
      complete_planet_hard_mode: { reached: false, icon: 'achievements/onthemoon.png', description: 'Planet Hard Mode. Unlock Explosive Rocket.' },
      complete_planet_hero_mode: { reached: false, icon: 'achievements/planet_huge.png', description: 'Planet Hero Mode' },

    };

    function updateAchievementsAtEnd() {
      if (wave >= 2) {
        Achievements.reach_wave_2.reached = true;
      }
      if (wave >= 5) {
        Achievements.reach_wave_5.reached = true;
      }

      if (wave >= 10) {
        Achievements.reach_wave_10.reached = true;
      }
      // if (wave >= 15) {
      //   Achievements.reach_wave_15.reached = true;
      // }
      if (wave >= 20) {
        Achievements.reach_wave_20.reached = true;
      }
      // if (wave >= 25) {
      //   Achievements.reach_wave_25.reached = true;
      // }
      if (damageReport.acid >= Achievements.acid_bomb_damage.required) {
        Achievements.acid_bomb_damage.reached = true;
      }

      if (damageReport.explosive >= Achievements.explosive_laser_damage.required) {
        Achievements.explosive_laser_damage.reached = true;
      }
      if (asteroidsKilled >= 100) {
        Achievements.destroy_100_asteroids.reached = true;
      }
      // if (asteroidsKilled >= 500) {
      //   Achievements.destroy_500_asteroids.reached = true;
      // }
      if (lives === 3) {
        Achievements.no_lives_lost.reached = true;
      }
      if (!Achievements.complete_easy_mode.reached && currentMode === GameModes.EASY && wave >= 31) {
        Achievements.complete_easy_mode.reached = true;
      }
      if (!Achievements.complete_normal_mode.reached && currentMode === GameModes.NORMAL && wave >= 31) {
        Achievements.complete_normal_mode.reached = true;
      }
      if (!Achievements.complete_hard_mode.reached && currentMode === GameModes.HARD && wave >= 31) {
        Achievements.complete_hard_mode.reached = true;
      }
      if (!Achievements.complete_hero_mode.reached && currentMode === GameModes.HERO && wave >= 31) {
        Achievements.complete_hero_mode.reached = true;
      }
      if (!Achievements.complete_meteor_easy_mode.reached && currentMode === GameModes.METEORSHOWEREASY && wave >= 31) {
        Achievements.complete_meteor_easy_mode.reached = true;
      }
      if (!Achievements.complete_meteor_normal_mode.reached && currentMode === GameModes.METEORSHOWERNORMAL && wave >= 31) {
        Achievements.complete_meteor_normal_mode.reached = true;
      }
      if (!Achievements.complete_meteor_hard_mode.reached && currentMode === GameModes.METEORSHOWERHARD && wave >= 31) {
        Achievements.complete_meteor_hard_mode.reached = true;
      }
      if (!Achievements.complete_meteor_hero_mode.reached && currentMode === GameModes.METEORSHOWERHERO && wave >= 31) {
        Achievements.complete_meteor_hero_mode.reached = true;
      }
      if (!Achievements.complete_planet_easy_mode.reached && currentMode === GameModes.PLANETEASY && wave >= 31) {
        Achievements.complete_planet_easy_mode.reached = true;
      }
      if (!Achievements.complete_planet_normal_mode.reached && currentMode === GameModes.PLANETNORMAL && wave >= 31) {
        Achievements.complete_planet_normal_mode.reached = true;
      }
      if (!Achievements.complete_planet_hard_mode.reached && currentMode === GameModes.PLANETHARD && wave >= 31) {
        Achievements.complete_planet_hard_mode.reached = true;
      }
      if (!Achievements.complete_planet_hero_mode.reached && currentMode === GameModes.PLANETHERO && wave >= 31) {
        Achievements.complete_planet_hero_mode.reached = true;
      }

      if (!Achievements.death_ray_damage.reached && damageReport.deathRay >= Achievements.death_ray_damage.required) {
        Achievements.death_ray_damage.reached = true;
      }

      if (!Achievements.drone_damage.reached && damageReport.drone >= Achievements.drone_damage.required) {
        Achievements.drone_damage.reached = true;
      }

      if (!Achievements.laser_damage.reached && damageReport.lasers >= Achievements.laser_damage.required) {
        Achievements.laser_damage.reached = true;
      }

      if (!Achievements.kill_5_aliens.reached && aliensKilled >= 5) {
        Achievements.kill_5_aliens.reached = true;
      }

      if (!Achievements.kill_15_aliens.reached && aliensKilled >= 15) {
        Achievements.kill_15_aliens.reached = true;
      }

      localStorage.setItem('achievements', JSON.stringify(Achievements));

      // saveAchievements();
      populateAchievements();
    }

    window.onload = loadWeaponInfo;

    // for leaderboard and telegram API 
    let gameId = "InfiniteSpaceWar";

  </script>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>
  <script>

    let userId = "";
    const firebaseConfig = {
      apiKey: "AIzaSyCvgdn8c6D8RusKRr4vHAzFj1x4FNxrXVE",
      authDomain: "infinite-games-9c69e.firebaseapp.com",
      projectId: "infinite-games-9c69e",
      storageBucket: "infinite-games-9c69e.appspot.com",
      messagingSenderId: "602022483888",
      appId: "1:602022483888:web:f967a6c1cb236ae66ba875",
      measurementId: "G-9LE6E1BKZ7"
    };

    let starHawk = false;

  </script>
  <script type="module">

    // import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    // import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-analytics.js";
    // import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-analytics.js";
    import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    // import { getFirestore, doc, getDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
    import { getFirestore, doc, updateDoc, arrayUnion, getDoc, getDocs, collection } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";


    // Firebase configuration and initialization
    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);
    const auth = getAuth(app);
    const db = getFirestore(app);


    const shipSwitcher = document.getElementById('shipType');
    shipSwitcher.addEventListener('click', (event) => {
      if (Achievements.complete_meteor_hard_mode.reached == true) {
        shipSwitcher.innerHTML = 'Ship type: Starhawk';
        starHawk = true;
        ship.laserLevel = 5;
        activateWeaponClass('turret');
        damageReportStartTimes.turret = Date.now();
        turret.damage = 5;
        turret.damageLevel = 5;
        turretUpgrades.damage = 5;

      }

    });




    const loginLink = document.getElementById('login-link');
    const loginPopup = document.getElementById('loginPopup');
    const loginForm = document.getElementById('loginForm');
    const userInfo = document.getElementById('userInfo');
    const userNickname = document.getElementById('userNickname');
    const logoutLink = document.getElementById('logoutLink');
    const loginContainer = document.getElementById('loginContainer');

    loginLink.addEventListener('click', (event) => {
      event.preventDefault();
      pauseGame();
      loginPopup.style.display = 'block';
    });

    loginForm.addEventListener('submit', (event) => {
      event.preventDefault();
      const email = document.getElementById('email').value;
      const password = document.getElementById('password').value;

      signInWithEmailAndPassword(auth, email, password)
        .then((userCredential) => {
          const user = userCredential.user;
          loadUserData(user.uid);
          loginPopup.style.display = 'none';
          resumeGame();
        })
        .catch((error) => {
          console.error('Error signing in:', error.message);
        });
    });

    logoutLink.addEventListener('click', (event) => {
      event.preventDefault();
      auth.signOut()
        .then(() => {
          userInfo.style.display = 'none';
          loginLink.style.display = 'block';
        })
        .catch((error) => {
          console.error('Error signing out:', error);
        });
    });

    document.getElementById('login-form').addEventListener('submit', function (event) {
      event.preventDefault();
      const email = document.getElementById('email').value;
      const password = document.getElementById('password').value;
      auth.signInWithEmailAndPassword(email, password)
        .then(userCredential => {
          const user = userCredential.user;
          loadUserData(user.uid);
        })
        .catch(error => {
          console.error("Error signing in:", error.message);
        });
    });

    auth.onAuthStateChanged(user => {
      if (user) {
        loadUserData(user.uid);
        userId = user.uid;
      } else {
        userInfo.style.display = 'none';
        loginContainer.style.display = 'block';
        pauseGame();
      }
    });

    function pauseGame() {
      if (!isPaused) {
        clearInterval(gameLoop);
        isPaused = true;
      }
    }

    function resumeGame() {
      if (isPaused) {
        clearInterval(gameLoop);
        gameLoop = setInterval(update, 1000 / 60);
        isPaused = false;
      }
    }

    async function loadUserData(userId) {
      try {
        const userDoc = await getDoc(doc(db, 'users', userId));

        if (userDoc.exists()) {
          const userData = userDoc.data();
          // document.getElementById('user-nickname').textContent = userData.nickname;

          userNickname.textContent = userData.nickname;
          userInfo.style.display = 'block';
          loginLink.style.display = 'none';

          // document.getElementById('user-coins').textContent = userData.coins;
          // document.getElementById('user-info').classList.remove('hidden');
          document.getElementById('login-link').classList.add('hidden');
          document.getElementById('auth').classList.add('hidden');
          // console.log(userData);

          // Load the achievements for the specific game
          const gameAchievements = userData.games?.[gameId]?.achievements || {};
          Object.assign(Achievements, gameAchievements);
          // console.log(Achievements);
          // console.log(gameAchievements);
          populateAchievements();

        } else {
          console.log("No such document!");
        }
      } catch (error) {
        console.error("Error getting user data:", error);
      }
    }

    // document.getElementById('login-toggle').addEventListener('click', function (event) {
    //   event.preventDefault();
    //   document.getElementById('auth').classList.toggle('hidden');
    // });

    // Function to save user score for a specific game
    async function saveUserScore(userId, gameName, gameData) {
      const db = getFirestore();
      const userDocRef = doc(db, 'users', userId);
      const loginTime = new Date();
      const sessionLength = loginTime - gameStartTime;

      if (typeof gameData === 'undefined' || typeof sessionLength === 'undefined') {
        console.error('Invalid game data or session length');
        return;
      }

      const userDoc = await getDoc(userDocRef);
      console.log(Achievements);
      if (userDoc.exists()) {
        const userData = userDoc.data();
        const existingAchievements = userData.games?.[gameName]?.achievements || {};

        // Merge the existing achievements with the updated achievements
        const updatedAchievements = { ...existingAchievements, ...Achievements };
        console.log("updated");
        console.log(updatedAchievements);

        // Save the score, session length, login time, and updated achievements for the specific game
        const fullGameData = {
          [`games.${gameName}.scores`]: arrayUnion({
            score: gameData.score,
            topWeapons: gameData.topWeapons,
            sessionLength: sessionLength,
            loginTime: loginTime
          }),
          [`games.${gameName}.achievements`]: updatedAchievements
        };

        await updateDoc(userDocRef, fullGameData);
      } else {
        console.log("no dice");

        // If the user document doesn't exist, create a new one with the initial achievements
        const gameData = {
          [`games.${gameName}.scores`]: [
            {
              score: score,
              sessionLength: sessionLength,
              loginTime: loginTime
            }
          ],
          [`games.${gameName}.achievements`]: Achievements
        };


        await setDoc(userDocRef, gameData);
      }
    }

    window.saveUserScore = saveUserScore;

    // Function to save initial user data
    async function saveUserData(userId, gameName) {
      const db = getFirestore();
      const userDocRef = doc(db, 'users', userId);
      const userData = {
        [`games.${gameName}`]: {
          scores: [],
          lastLogin: new Date()
        }
      };
      await setDoc(userDocRef, userData, { merge: true });
    }

    window.saveUserData = saveUserData;

    // Function to load leaderboard for a specific game
    async function loadLeaderboard(gameName) {
      const db = getFirestore();
      const usersSnapshot = await getDocs(collection(db, 'users'));
      const users = [];

      usersSnapshot.forEach(doc => {
        const userData = doc.data();
        const gameScores = userData.games?.[gameName]?.scores || [];
        const highestScore = gameScores.reduce((max, session) => Math.max(max, session.score), 0);

        users.push({
          nickname: userData.nickname || 'Unnamed',
          score: highestScore
        });
      });

      users.sort((a, b) => b.score - a.score);
      const topUsers = users.slice(0, 10);

      const leaderboard = document.createElement('div');
      leaderboard.innerHTML = `<h2>Leaderboard for ${gameName}</h2>`;
      topUsers.forEach((user, index) => {
        const userDiv = document.createElement('div');
        userDiv.innerText = `${index + 1}. ${user.nickname}: ${user.score} points`;
        leaderboard.appendChild(userDiv);
      });

      document.getElementById('leaderboard-container').appendChild(leaderboard);
    }

    // Possible future verion
    //     async function loadLeaderboard(gameName) {
    //   // ...

    //   usersSnapshot.forEach(doc => {
    //     const userData = doc.data();
    //     const gameScores = userData.games?.[gameName]?.scores || [];
    //     const highestScore = gameScores.reduce((max, session) => Math.max(max, session.score), 0);
    //     const topWeapons = gameScores.find(session => session.score === highestScore)?.topWeapons || [];

    //     users.push({
    //       nickname: userData.nickname || 'Unnamed',
    //       score: highestScore,
    //       topWeapons: topWeapons
    //     });
    //   });

    //   // ...

    //   topUsers.forEach((user, index) => {
    //     const userDiv = document.createElement('div');
    //     userDiv.innerText = `${index + 1}. ${user.nickname}: ${user.score} points`;

    //     const weaponsDiv = document.createElement('div');
    //     weaponsDiv.innerText = 'Top Weapons: ' + user.topWeapons.map(weapon => `${weapon.weapon} (${weapon.damage})`).join(', ');

    //     leaderboard.appendChild(userDiv);
    //     leaderboard.appendChild(weaponsDiv);
    //   });

    //   // ...
    // }

    window.loadLeaderboard = loadLeaderboard;

    // Function to calculate session length (to be implemented as needed)
    function calculateSessionLength() {
      // Placeholder implementation
      return Math.floor(Math.random() * 1000); // Replace with actual session length calculation
    }


    // Function to save achievements
    // async function saveAchievements() {
    //   const Achievements = JSON.parse(localStorage.getItem('achievements')) || {};
    //   const params = new URLSearchParams(window.location.search);
    //   const userId = params.get('userId');
    //   if (!userId) return;

    //   const db = getFirestore();
    //   const userDocRef = doc(db, 'users', userId);

    //   // Update the achievements in Firestore
    //   const achievementsData = {
    //     achievements: Achievements
    //   };

    //   await updateDoc(userDocRef, achievementsData);
    //   await setAchievementsFromApi(Achievements); // Implement this function as needed
    // }

    // window.saveAchievements = saveAchievements;

    // Function to load achievements from Firebase or localStorage
    async function loadAchievements() {
      const params = new URLSearchParams(window.location.search);
      const userId = params.get('userId');
      const db = getFirestore();
      let loadedAchievements = {};

      if (userId) {
        const userDocRef = doc(db, 'users', userId);
        const userDoc = await getDoc(userDocRef);

        if (userDoc.exists() && userDoc.data().achievements) {
          loadedAchievements = userDoc.data().achievements;
        } else {
          const savedAchievements = localStorage.getItem('achievements');
          if (savedAchievements) {
            loadedAchievements = JSON.parse(savedAchievements);
          }
        }
      } else {
        const savedAchievements = localStorage.getItem('achievements');
        if (savedAchievements) {
          loadedAchievements = JSON.parse(savedAchievements);
        }
      }
      Object.assign(Achievements, loadedAchievements);

      return Achievements;
    }

    window.loadAchievements = loadAchievements;

  </script>









  <script src="js/ships.js"></script>





  <script src="js/audio.js"></script>




































  <script src="infinite/leaderboard.js"></script>

  <script src="js/aliens.js"></script>


  <div id="auth" class="hidden">
    <h1>Infinite Games</h1>
    <h2>Login</h2>
    <form id="login-form">
      <input type="email" id="email" placeholder="Email" required>
      <input type="password" id="password" placeholder="Password" required>
      <button type="submit">Login</button>
    </form>
  </div>






  <!-- #INFINITEGAMES JS START -->
  <!-- <script src="infinite/js/48_leaderboard_20240618013040.js"></script> -->
  <!-- <script src="infinite/js/48_firebase_20240618013040.js"></script> -->
  <!-- #INFINITEGAMES JS END -->
</body>

</html>