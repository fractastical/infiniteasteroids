<!DOCTYPE html>
<html>

<head>
  <title>Infinite Asteroids</title>
  <link href="styles.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">








  <!-- #INFINITEGAMES CSS START -->
  <!-- <link rel="stylesheet" href="infinite/css/48_leaderboard_20240709215443.css"> -->
  <!-- #INFINITEGAMES CSS END -->
</head>

<body>

  <div id="leftArrow" class="flashing-arrow" style="left: 20px; top: 50%;"></div>
  <div id="rightArrow" class="flashing-arrow" style="right: 20px; top: 50%;"></div>


  <div id="loginPopup" class="modal">
    <div class="modal-content">
      <h2>Login</h2>
      <form id="loginForm">
        <input type="email" id="email" placeholder="Email" required>
        <input type="password" id="password" placeholder="Password" required>
        <button type="submit">Login</button>
      </form>
      <form id="signup-form">
        <h2>Sign Up</h2>
        <input type="text" id="signup-nickname" placeholder="Nickname" required>
        <input type="email" id="signup-email" placeholder="Email" required>
        <input type="password" id="signup-password" placeholder="Password" required>
        <button type="submit">Sign Up</button>
      </form>

    </div>
  </div>

  <!-- Add this somewhere appropriate in your body tag -->
  <div id="upgradeShopModal" class="modal">
    <div class="modal-content">
      <h2>Upgrade Shop</h2>
      <div id="upgrade-shop" class="upgrade-container"></div>
      <button id="closeUpgradeShop">Close Shop</button>
    </div>
  </div>

  <div id="shipCustomizationModal" class="modal">
    <div class="modal-content">
      <h2>Ship Customization</h2>
      <div id="shipPreview"></div>
      <div id="equippedUpgrades" class="upgrade-container">
        <h3>Equipped Upgrades</h3>
        <!-- Equipped upgrades will be added here dynamically -->
      </div>
      <div id="availableUpgrades" class="upgrade-container">
        <h3>Used Upgrades</h3>
        <!-- Available upgrades will be added here dynamically -->
      </div>
      <button id="saveCustomization">Save and Close</button>
    </div>
  </div>


  <div class="top-right" id="loginContainer">
    <a href="#" id="login-link">Login</a>
  </div>

  <div class="top-right hidden" id="userInfo">
    <span id="userNickname"></span> | <a href="#" id="logoutLink">Logout</a>
  </div>


  <div id="xpBarContainer">
    <div id="xpBar"></div>
  </div>

  <!-- version -->
  <div id="shipType">
    Ship type: Basic&nbsp;&nbsp; &nbsp; v 0.9419.
  </div>


  <div id="technologiesCount">

  </div>
  <!-- 
  <div id="result">

  </div>
 -->
  <div id="levelUpModal" class="modal">
    <div class="modal-content">
      <h2>Level Up!</h2>
      <p>Choose an upgrade:</p>
      <button id="upgrade1" onclick="selectUpgrade(1)"></button>
      <button id="upgrade2" onclick="selectUpgrade(2)"></button>
      <button id="upgrade3" onclick="selectUpgrade(3)"></button>
      <button id="upgrade4" style="display:none" onclick="selectUpgrade(4)"></button>

    </div>
  </div>


  <div id="rouletteContainer" style="display: none">
    <div id="rouletteIcons"></div>
    <div id="planet"></div>
    <div id="upgradeDisplay"></div>
    <button id="spinButton" onClick="startRoulette()">Spin [ENTER]</button>

  </div>




  <div id="activeWeaponClassesContainer" class="bottom-icons">
  </div>

  <canvas id="gameCanvas" width="800" height="600"></canvas>

  <div id="bottomContent">
    <div id="waveCounter"></div>
    <div id="coinsDisplay"></div>
    <div id="livesDisplay"></div>
    <div id="controlsInfo"></div>
  </div>



  <div id="endScreen" class="screen">
    <h2>Game Over</h2>
    <p><span id="wave"></span>

    </p>
    <p id="score"></p>
    <p id="asteroidsDestroyed"></p>
    <!-- <p id="bonusCoins"></p> -->

    <h3>Damage Report</h3>
    <ul id="damageReportList"></ul>

    <h3>Recently Unlocked Weapons</h3>
    <ul id="unlockedWeaponsList"></ul>

    <h3>New Achievements</h3>
    <ul id="newAchievementsList"></ul>

    <h3>Used Upgrades</h3>
    <ul id="upgradesList"></ul>
    <p><button id="restartButton">Restart</button></p>

    <div id="leaderboard-container">
      <div id="leaderboard">
        <h2>Leaderboard</h2>
        <ol id="leaderboard-list"></ol>
      </div>
    </div>
  </div>



  <div id="startScreen">
    <div>
      <h2>Welcome to Infinite Asteroids!</h2>
      <p>Unlock next level when you reach wave 30.</p>
      <table>

        <tr>
          <th>
            <p>Deep Space</p>
          </th>
          <th>
            <p>Meteor Shower</p>
          </th>
          <th>
            <p>Planet</p>
          </th>
        </tr>
        <tr>
          <td>

            <button id="easyButton" onclick="initializeGame(GameModes.EASY)">Easy</button>
            <button id="normalButton" onclick="initializeGame(GameModes.NORMAL)">Normal</button>
            <button id="hardButton" onclick="initializeGame(GameModes.HARD)" disabled>Hard</button>
            <button id="heroButton" onclick="initializeGame(GameModes.HERO)" disabled>Hero</button>
          </td>
          <td>

            <button id="meteorEasyButton" onclick="initializeGame(GameModes.METEORSHOWEREASY)" disabled>Easy</button>
            <button id="meteorNormalButton" onclick="initializeGame(GameModes.METEORSHOWERNORMAL)"
              disabled>Normal</button>
            <button id="meteorHardButton" onclick="initializeGame(GameModes.METEORSHOWERHARD)" disabled>Hard</button>
            <button id="meteorHeroButton" onclick="initializeGame(GameModes.METEORSHOWERHERO)" disabled>Hero</button>
          </td>
          <td>


            <button id="planetEasyButton" onclick="initializeGame(GameModes.PLANETEASY)" disabled>Easy</button>
            <button id="planetNormalButton" onclick="initializeGame(GameModes.PLANETNORMAL)" disabled>Normal</button>
            <button id="planetHardButton" onclick="initializeGame(GameModes.PLANETHARD)" disabled>Hard</button>
            <button id="planetHeroButton" onclick="initializeGame(GameModes.PLANETHERO)" disabled>Hero</button>
          </td>
        </tr>
        <tr>
          <td>

            <button id="endlessSlowButton" onclick="initializeGame(GameModes.ENDLESS_SLOW)">Endless </button>


          </td>
          <!-- <td>

            <button id="coopButton" onclick="initializeGame(GameModes.COOP)">Co-op </button>


          </td>
 -->
        </tr>

        </tr>

      </table>

      <div id="achievementsContainer">

        <h3>Your Achievements</h3>
        <div id="achievementsList"></div>
      </div>
      <h3>Your Upgrades</h3>
      <div id="upgradesList"></div>


      <!-- <button onclick="initializeGame(GameModes.NORMAL)" ${!modesUnlocked.normal ? 'disabled' : '' }>Normal</button>
      <button onclick="initializeGame(GameModes.HARD)" ${!modesUnlocked.hard ? 'disabled' : '' }>Hard</button> -->
      <!-- <p>Tap lower left for store.</p> -->
      <!-- <p>Tap with two fingers to fire.</p> -->
      <!-- <button onclick="startGame()">Start Game</button> -->
    </div>
  </div>

  <div id="joystick">
    <div id="joystickHandle"></div>

  </div>

  <div id="weaponInfo">
    <h2>Weapon Information</h2>
    <div id="weaponsContainer">
      <!-- Weapon entries will be dynamically added here -->
    </div>
    <button id="closeButton" onclick="toggleWeaponInfo()">Close</button>
  </div>

  <div id="volumeScreen" style="display:none;">
    <h2>Volume Control</h2>
    <input type="range" id="volumeSlider" min="1" max="10" value="5">
    <p>Volume: <span id="volumeValue">5</span></p>
    <button onclick="toggleVolumeScreen()">Close</button>
  </div>



  <audio id="background-music" src="sounds/music_loop.mp3" loop></audio>

  <audio id="meteor-destroy-1" src="sounds/meteor_destroy.mp3"></audio>
  <audio id="meteor-destroy-2" src="sounds/meteor_destroy2.mp3"></audio>
  <audio id="meteor-destroy-3" src="sounds/meteor_destroy3.mp3"></audio>

  <audio id="shot-sound-1" src="sounds/shot1.mp3"></audio>
  <audio id="shot-sound-2" src="sounds/shot2.mp3"></audio>
  <audio id="shot-sound-3" src="sounds/shot3.mp3"></audio>

  <audio id="thruster-sound-1" src="sounds/thruster1.mp3"></audio>
  <audio id="thruster-sound-2" src="sounds/thruster2.mp3"></audio>
  <audio id="thruster-sound-3" src="sounds/thruster3.mp3"></audio>

  <audio id="ship-destroyed" src="sounds/ship_destroyed.mp3"></audio>

  <audio id="alien-entering-sound" src="sounds/alien_entering.mp3"></audio>

  <audio id="alien-laser-1" src="sounds/alien_laser1.mp3"></audio>
  <audio id="alien-laser-2" src="sounds/alien_laser2.mp3"></audio>
  <audio id="alien-laser-3" src="sounds/alien_laser3.mp3"></audio>

  <audio id="gem-collecting-sound" src="sounds/bird_chirp.mp3"></audio>

  <audio id="freeze-sound" src="sounds/freeze.mp3"></audio>
  <audio id="freeze-sound-2" src="sounds/freezew.mp3"></audio>
  <audio id="death-ray-sound" src="sounds/dray1.mp3"></audio>
  <audio id="deploy-drone-sound" src="sounds/deploy_drone.mp3"></audio>
  <audio id="acid-bomb-sound" src="sounds/acid_bomb.mp3"></audio>
  <audio id="bomb-lay-sound" src="sounds/lay_bomb.mp3"></audio>
  <audio id="lightning-sound" src="sounds/lightning_echo.mp3"></audio>
  <audio id="flamethrower" src="sounds/flamethrow.mp3"></audio>


  <!-- <button id="restartButton" style="display: none;">Home</button> -->



  <script>
    // Get the canvas element
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const joystick = document.getElementById('joystick');
    const joystickInner = document.getElementById('joystick-inner');
    const joystickHandle = document.getElementById('joystickHandle');
    const restartButton = document.getElementById('restartButton');
    const backgroundMusic = document.getElementById('background-music');

    let isTouchingJoystick = false;
    let joystickStartX, joystickStartY;
    let isMusicPlaying = true; // Flag to track music state

    const coinsDisplay = document.getElementById('coins');

    const laserLevelDisplay = document.getElementById('laserLevel');
    // const accelerationLevelDisplay = document.getElementById('accelerationLevel');
    const maxBulletsLevelDisplay = document.getElementById('maxBulletsLevel');
    const rotationSpeedLevelDisplay = document.getElementById('rotationSpeedLevel');
    const droneSpeedLevelDisplay = document.getElementById('droneSpeedLevel');
    // const droneLaserSpeedLevelDisplay = document.getElementById('droneLaserSpeedLevel');
    const droneLaserIntervalLevelDisplay = document.getElementById('droneLaserIntervalLevel');

    let activeWeaponClasses = []; // Array to store active weapon classes
    let particles = []; // Array to store thruster particles

    let level = 1;
    let xp = 0;
    let xpToNextLevel = 300;

    let acidBomb = {
      cooldown: 300,
      timer: 0,
      duration: 300, // Duration the acid effect lasts (5 seconds at 60 FPS)
      damagePerSecond: 1,
      size: 50,
      activeBombs: [],
      activeAreas: []
    };

    let acidBombUpgrades = {
      duration: 1,
      cooldown: 1,
      size: 1
    };

    let meteorBooster = 0;
    let modeScoreMultiplier = 1;
    let megaExplosions = [];



    const GameModes = {
      EASY: 'easy',
      NORMAL: 'normal',
      HARD: 'hard',
      HERO: 'heroic',
      METEORSHOWEREASY: 'meteorshowereasy',
      METEORSHOWERNORMAL: 'meteorshowernormal',
      METEORSHOWERHARD: 'meteorshowerhard',
      METEORSHOWERHERO: 'meteorshowerhero',
      PLANETEASY: 'planeteasy',
      PLANETNORMAL: 'planetnormal',
      PLANETHARD: 'planethard',
      PLANETHERO: 'planethero',
      ENDLESS_SLOW: 'endless_slow',
      COOP: 'coop'

    };

    let currentMode = GameModes.EASY; // Start with Easy mode by default
    let modesUnlocked = {
      easy: true,
      normal: false,
      hard: false,
      hero: false,
      meteoreasy: false,
      meteornormal: false,
      meteorhard: false,
      planeteasy: false,
      planetnormal: false,
      planethard: false,
      planethero: false

    };

    const planet = { x: canvas.width / 2 + 200, y: canvas.height / 2 + 200, radius: 70 };
    let gravityStrength = 0;


    let ship = {
      x: canvas.width / 2,
      y: canvas.height - 50,
      size: 20,
      speed: 0,
      acceleration: 0.15,
      deceleration: 0.96,
      maxSpeed: 3,
      rotation: 0,
      rotationSpeed: 2.5,
      lasers: [],
      velocityX: 0,
      velocityY: 0,
      laserLevel: 2,
      accelerationLevel: 1,
      rotationSpeedLevel: 1,
      maxBulletsLevel: 1,
      explosiveLaserLevel: 0,
      laserCooldown: 30,
      laserTimer: 0,
      laserCooldownLevel: 1,
      weaponSlots: 5,
      upgradeSlots: 2,
      initialSlowDown: true,


    };

    let ship2 = {
      x: canvas.width / 2,
      y: canvas.height - 100,
      size: 20,
      speed: 0,
      acceleration: 0.15,
      deceleration: 0.96,
      maxSpeed: 5,
      rotation: 0,
      rotationSpeed: 2.5,
      lasers: [],
      velocityX: 0,
      velocityY: 0,
      laserLevel: 2,
      accelerationLevel: 1,
      rotationSpeedLevel: 1,
      maxBulletsLevel: 1,
      explosiveLaserLevel: 0,
      laserCooldown: 30,
      laserTimer: 0,
      laserCooldownLevel: 1,
      weaponSlots: 5,
      upgradeSlots: 2,
      initialSlowDown: true,


    };

    let shipRelativeX = ship.x / canvas.width;
    let shipRelativeY = ship.y / canvas.height;

    function updateShipPositionAfterResize() {
      ship.x = shipRelativeX * canvas.width;
      ship.y = shipRelativeY * canvas.height;
    }



    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      resetShip();
      // Scale the canvas to handle high DPI screens
      // ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      // // Reposition the ship to the center of the canvas
      // ship.x = canvas.width / 2 / window.devicePixelRatio;
      // ship.y = canvas.height - 50 / window.devicePixelRatio;
    };
    resizeCanvas();


    // KEY CONFIG VARs
    let coins = 10000;


    let score = 0;
    let asteroids = [];
    let gameLoop;
    let explosions = [];
    let lives = 3;
    let testMode = false;

    if (testMode)
      lives = 1;
    let gameOver = false;
    let invincible = false;
    let invincibilityTimer = 0;


    let wave = 1;
    let waveMessageTimer = 0;
    const waveMessageDuration = 180; // 3 seconds (60 FPS)
    let asteroidsKilled = 0;
    let aliensKilled = 0;
    let drones = [];
    const droneCost = 800;
    let spawnCooldown = 12; // Cooldown time in seconds
    let spawnTimer = spawnCooldown;
    let bonusCoins = 0;

    let droneUpgrades = {
      damageLevel: 1,
      speed: 1,
      laserSpeed: 1,
      laserInterval: 1

    };


    // Event listeners for keyboard input
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
    document.addEventListener('fullscreenchange', () => {
      if (document.fullscreenElement) {
        // Store ship's position relative to canvas size
        shipRelativeX = ship.x / canvas.width;
        shipRelativeY = ship.y / canvas.height;

        // Adjust canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Update ship's position based on new canvas size
        updateShipPositionAfterResize();
      } else {
        // Handle exit full screen if needed
        shipRelativeX = ship.x / canvas.width;
        shipRelativeY = ship.y / canvas.height;

        // Reset canvas size (example: original width and height)
        canvas.width = originalWidth;
        canvas.height = originalHeight;

        // Update ship's position based on new canvas size
        updateShipPositionAfterResize();
      }
    });

    window.addEventListener('resize', () => {
      if (document.fullscreenElement) {
        // Store ship's position relative to canvas size
        shipRelativeX = ship.x / canvas.width;
        shipRelativeY = ship.y / canvas.height;

        // Adjust canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Update ship's position based on new canvas size
        updateShipPositionAfterResize();
      }
    });

    let achievements = [];





    let touchAccelerating = false;

    canvas.addEventListener('touchstart', handleTouch);
    canvas.addEventListener('touchmove', handleTouch);
    canvas.addEventListener('touchend', () => {
      touchAccelerating = false;
    });

    function handleTouch(e) {
      e.preventDefault(); // Prevent default touch behaviors

      if (e.touches.length === 1) {
        const touch = e.touches[0];
        const touchX = touch.clientX;
        const canvasWidth = canvas.width;
        const partWidth = canvasWidth / 5; // Divide the canvas width into 5 parts

        if (touchX < partWidth) {
          // Hard left turn
          ship.rotation -= (ship.rotationSpeed * 3);
        } else if (touchX < partWidth * 2) {
          // Soft left turn
          ship.rotation -= ship.rotationSpeed;
        } else if (touchX < partWidth * 3) {
          // Acceleration
          touchAccelerating = true;
        } else if (touchX < partWidth * 4) {
          // Soft right turn
          ship.rotation += ship.rotationSpeed;
        } else {
          // Hard right turn
          ship.rotation += (ship.rotationSpeed * 3);
        }

      }

      if (e.target === canvas && e.touches.length === 2) {
        // Two-finger touch for firing
        if (ship.lasers.length < (ship.maxBulletsLevel * 3) && ship.laserTimer === 0) {
          shootLasers();
        }
      }
    }

    let gameStartTime;
    let gameEndTime;



    let initialSlowDown = true;

    let currentBackgroundImage = null;


    function updateShip(ship, leftKey, rightKey, upKey, downKey, shootKey) {
      let angle = ship.rotation * Math.PI / 180;

      if (keys[leftKey]) {
        ship.rotation -= ship.rotationSpeed;
      }
      if (keys[rightKey]) {
        ship.rotation += ship.rotationSpeed;
      }

      if (keys[upKey] || (ship === ship && touchAccelerating)) {
        if (!toggleOff) backgroundMusic.play();
        playRandomThrusterSound();

        let accelerationAmount = ship.acceleration;

        if (ship === ship && touchAccelerating)
          accelerationAmount *= 2;
        ship.velocityX += accelerationAmount * Math.sin(angle);
        ship.velocityY -= accelerationAmount * Math.cos(angle);

        generateThrusterParticles(ship);
        ship.initialSlowDown = true;

      } else if (keys[downKey]) {
        if (ship.initialSlowDown) {
          ship.velocityX *= 0.75;
          ship.velocityY *= 0.75;
          if (Math.abs(ship.velocityX) < 2 && Math.abs(ship.velocityY) < 2) {
            ship.initialSlowDown = false;
          }
        }
        else {
          ship.velocityX *= 0.95;
          ship.velocityY *= 0.95;
        }

        if (Math.abs(ship.velocityX) < 0.9 && Math.abs(ship.velocityY) < 0.9) {
          if (!toggleOff) backgroundMusic.play();
          playRandomThrusterSound();

          const initialBackwardAcceleration = ship.acceleration * 1.5;
          const backwardSpeed = ship.maxSpeed;
          ship.velocityX -= initialBackwardAcceleration * Math.sin(angle);
          ship.velocityY += initialBackwardAcceleration * Math.cos(angle);

          generateThrusterParticles(ship);
        }
      } else {
        ship.velocityX *= ship.deceleration;
        ship.velocityY *= ship.deceleration;
      }

      // Limit the ship's speed to maxSpeed
      let speed = Math.sqrt(ship.velocityX * ship.velocityX + ship.velocityY * ship.velocityY);
      if (speed > ship.maxSpeed) {
        let ratio = ship.maxSpeed / speed;
        ship.velocityX *= ratio;
        ship.velocityY *= ratio;
      }

      if (keys[shootKey] && ship.lasers.length < (ship.maxBulletsLevel * 3) && ship.laserTimer === 0) {
        shootLasers(ship);
      }

      ship.x += ship.velocityX;
      ship.y += ship.velocityY;

      if (ship.x < 0) ship.x = canvas.width;
      else if (ship.x > canvas.width) ship.x = 0;
      if (ship.y < 0) ship.y = canvas.height;
      else if (ship.y > canvas.height) ship.y = 0;
    }

    function drawPlanet() {
      const gradient = ctx.createRadialGradient(
        planet.x,
        planet.y,
        0,
        planet.x,
        planet.y,
        planet.radius
      );
      gradient.addColorStop(0, 'rgba(255, 0, 0, 1)'); // Center color (solid red)
      gradient.addColorStop(1, 'rgba(128, 0, 0, 1)'); // Edge color (darker red)

      ctx.beginPath();
      ctx.arc(planet.x, planet.y, planet.radius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.closePath();
    }

    function drawEdgeOverlay() {
      const overlayWidth = canvas.width * 0.05;
      const overlayHeight = canvas.height * 0.05;

      ctx.fillStyle = 'rgba(0, 0, 0, 0.99)'; // Semi-transparent black color

      // Top overlay
      ctx.fillRect(0, 0, canvas.width, overlayHeight);
      // Bottom overlay
      ctx.fillRect(0, canvas.height - overlayHeight, canvas.width, overlayHeight);
      // Left overlay
      ctx.fillRect(0, 0, overlayWidth, canvas.height);
      // Right overlay
      ctx.fillRect(canvas.width - overlayWidth, 0, overlayWidth, canvas.height);
    }


    // Function to generate thruster particles
    function generateThrusterParticles() {
      const angle = ship.rotation * Math.PI / 180;
      const particle = {
        x: ship.x - Math.sin(angle) * ship.size,
        y: ship.y + Math.cos(angle) * ship.size,
        size: Math.random() * 3 + 1,
        speed: Math.random() * 2 + 1,
        direction: angle + Math.PI,
        life: Math.random() * 30 + 20,
        color: 'rgba(255, 165, 0, 0.8)'
      };
      particles.push(particle);
    }

    // Function to update particles
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        particle.x += Math.sin(particle.direction) * particle.speed;
        particle.y -= Math.cos(particle.direction) * particle.speed;
        particle.life--;
        if (particle.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    // Function to draw particles
    function drawParticles() {
      for (const particle of particles) {
        ctx.fillStyle = particle.color;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }



    function isMobile() {
      return /Mobi|Android/i.test(navigator.userAgent);

    }

    document.addEventListener('DOMContentLoaded', () => {

      // loadAchievements();
      // populateAchievements();
      if (isMobile()) {
        document.getElementById('joystick').style.display = 'block';
        document.getElementById('startScreen').style.display = 'flex';
      } else {
        // startGame();
      }
    });




    let asteroidDifficultySpeedMultiplier = 1;
    let levelUpXPMultiplier = 1.2;
    let meteorMode = false;
    let planetMode = false;
    let invincibilityDuration = 160; // 3.5 seconds (60 FPS)


    function checkAlienDamage(weapon) {

      let actualDamage = 0;

      for (let j = swarmingAliens.length - 1; j >= 0; j--) {
        const swarmingalien = swarmingAliens[j];
        if (isColliding(weapon, swarmingalien)) {
          swarmingAliens.splice(j, 1);
          increaseXP(40);
          score += 40;
          actualDamage += 1;
          createExplosion(swarmingalien.x, swarmingalien.y, 1);
          break;
        }


      }

      for (let j = aliens.length - 1; j >= 0; j--) {
        const alien = aliens[j];
        actualDamage += 1;
        if (isColliding(weapon, alien)) {
          createExplosion(alien.x, alien.y);
          aliens.splice(aliens.indexOf(alien), 1);
          increaseXP(300);
          aliensKilled++;
          score += 300; // Adjust the score as needed
          break;
        }
      }

      if (alien && isColliding(weapon, alien)) {

        actualDamage = Math.min(weapon.damage + damageBooster, alien.hitpoints); // Ensure we don't overkill the asteroid
        alien.hitpoints -= actualDamage;

        createExplosion(alien.x, alien.y);

        if (alien.hitpoints <= 0) {
          createExplosion(alien.x, alien.y, 15);
          alien = null; // Destroy alien
          aliensKilled++;
          increaseXP(30 * 20);
          score += 1000;
        }
      }


      if (superbossAlien && isColliding(weapon, superbossAlien)) {

        actualDamage = Math.min(weapon.damage + damageBooster, superbossAlien.hitpoints); // Ensure we don't overkill the asteroid
        superbossAlien.hitpoints -= actualDamage;
        createExplosion(superbossAlien.x, superbossAlien.y);

        if (superbossAlien.hitpoints <= 0) {
          createExplosion(superbossAlien.x, superbossAlien.y, 50);
          createBossExplosion(superbossAlien.x, superbossAlien.y, 150);
          superbossAlien = null; // Destroy alien
          aliensKilled++;
          Achievements.alien_megaboss_killed.reached = true;
          increaseXP(30 * 20);
          score += 100000;
        }
      }


      if (megaBossAlien && isColliding(weapon, megaBossAlien)) {

        actualDamage = Math.min(weapon.damage + damageBooster, megaBossAlien.hitpoints); // Ensure we don't overkill the asteroid
        megaBossAlien.hitpoints -= actualDamage;

        createExplosion(megaBossAlien.x, megaBossAlien.y);

        if (megaBossAlien.hitpoints <= 0) {
          createExplosion(megaBossAlien.x, megaBossAlien.y, 50);
          megaBossAlien = null; // Destroy alien
          createBossExplosion(megaBossAlien.x, megaBossAlien.y, 250);
          aliensKilled++;
          Achievements.alien_supermegaboss_killed.reached = true;
          increaseXP(30 * 20);
          score += 100000;
        }
      }

      return actualDamage;
    }


    // Function to handle laser collisions
    function checkLaserCollisions(lasers, isShip) {
      for (let i = lasers.length - 1; i >= 0; i--) {
        let laser = lasers[i];


        for (let j = swarmingAliens.length - 1; j >= 0; j--) {
          const swarmingalien = swarmingAliens[j];
          if (isColliding(laser, swarmingalien)) {
            swarmingAliens.splice(j, 1);
            increaseXP(40);
            score += 40;
            createExplosion(swarmingalien.x, swarmingalien.y, 1);
            lasers.splice(i, 1); // Remove laser
            break;
          }


        }


        for (let j = aliens.length - 1; j >= 0; j--) {
          const alien = aliens[j];
          if (isColliding(laser, alien)) {
            handleLaserAlienCollision(laser, alien);
            break;
          }
        }

        if (alien && isColliding(laser, alien)) {

          let damage = isShip ? ship.laserLevel : 1; // Damage based on laserLevel for ship lasers
          let actualDamage = Math.min(damage + damageBooster, alien.hitpoints); // Ensure we don't overkill the asteroid
          alien.hitpoints -= actualDamage;

          createExplosion(alien.x, alien.y);

          if (alien.hitpoints <= 0) {
            createExplosion(alien.x, alien.y, 15);
            alien = null; // Destroy alien
            aliensKilled++;
            increaseXP(30 * 20);
            score += 1000;
          }
          lasers.splice(i, 1); // Remove laser
          break;
        }


        if (superbossAlien && isColliding(laser, superbossAlien)) {

          let damage = isShip ? ship.laserLevel : 1; // Damage based on laserLevel for ship lasers
          let actualDamage = Math.min(damage + damageBooster, superbossAlien.hitpoints); // Ensure we don't overkill the asteroid
          superbossAlien.hitpoints -= actualDamage;

          createExplosion(superbossAlien.x, superbossAlien.y);

          if (superbossAlien.hitpoints <= 0) {
            createExplosion(superbossAlien.x, superbossAlien.y, 50);
            createBossExplosion(superbossAlien.x, superbossAlien.y, 150);
            superbossAlien = null; // Destroy alien
            aliensKilled++;
            Achievements.alien_megaboss_killed.reached = true;
            increaseXP(30 * 20);
            score += 100000;
          }
          lasers.splice(i, 1); // Remove laser
          break;
        }


        if (megaBossAlien && isColliding(laser, megaBossAlien)) {

          let damage = isShip ? ship.laserLevel : 1; // Damage based on laserLevel for ship lasers
          let actualDamage = Math.min(damage + damageBooster, megaBossAlien.hitpoints); // Ensure we don't overkill the asteroid
          megaBossAlien.hitpoints -= actualDamage;

          createExplosion(megaBossAlien.x, megaBossAlien.y);

          if (megaBossAlien.hitpoints <= 0) {
            createExplosion(megaBossAlien.x, megaBossAlien.y, 50);
            megaBossAlien = null; // Destroy alien
            createBossExplosion(megaBossAlien.x, megaBossAlien.y, 250);
            aliensKilled++;
            Achievements.alien_supermegaboss_killed.reached = true;
            increaseXP(30 * 20);
            score += 100000;
          }
          lasers.splice(i, 1); // Remove laser
          break;
        }

        for (let j = asteroids.length - 1; j >= 0; j--) {
          let asteroid = asteroids[j];
          if (isColliding(laser, asteroid)) {
            let damage = isShip ? ship.laserLevel : 1; // Damage based on laserLevel for ship lasers

            let actualDamage = Math.min(damage + damageBooster, asteroid.hitpoints); // Ensure we don't overkill the asteroid
            asteroid.hitpoints -= actualDamage;

            if (asteroid.hitpoints <= 0) {
              //shrapnel
              if (asteroid.isLarge) {
                createSmallerAsteroids(asteroid.x, asteroid.y, asteroid.size, asteroid.speed, 1); // Split into smaller asteroids
              }
              asteroids.splice(j, 1);

              processAsteroidDeath(asteroid);


            } else {
              // Lighten the color slightly
              // let colorValue = Math.max(40, 30 + (asteroid.hitpoints * 3)); // Adjust color value
              // asteroid.color = `rgb(${colorValue}, ${colorValue}, ${colorValue})`;
            }

            lasers.splice(i, 1);
            score += actualDamage * 50; // Increase score based on actual damage

            playRandomMeteorDestroySound();
            coins += actualDamage * 20; // Add coins based on actual damage
            increaseXP(actualDamage * 20); // Increase XP based on actual damage

            // Track damage
            if (isShip) {
              damageReport.lasers += actualDamage;

              // Handle explosive laser effect
              if (ship.explosiveLaserLevel > 0) {
                createExplosion(laser.x, laser.y, 0);
                let areaDamage = createAreaDamage(laser.x, laser.y, ship.explosiveLaserLevel * 15, ship.laserLevel); // Increase radius based on explosiveLaserLevel and damage based on laserLevel
                damageReport.explosive += areaDamage;
              }
            } else {
              damageReport.turret += actualDamage;
            }

            break;
          }
        }
      }
    }


    function selectGemType(hitpoints) {
      const epicThreshold = 30;
      const rareThreshold = 15;

      // Probabilities (adjust these to fine-tune gem distribution)
      let commonProb = 0.7;
      let rareProb = 0.25;
      let epicProb = 0.05;

      // Adjust probabilities based on hitpoints
      if (hitpoints > epicThreshold) {
        epicProb += 0.15;
        rareProb += 0.10;
        commonProb -= 0.25;
      } else if (hitpoints > rareThreshold) {
        rareProb += 0.15;
        epicProb += 0.05;
        commonProb -= 0.20;
      }

      // Normalize probabilities
      const total = commonProb + rareProb + epicProb;
      commonProb /= total;
      rareProb /= total;
      epicProb /= total;

      // Weighted random selection
      const rand = Math.random();
      if (rand < commonProb) return 'common';
      if (rand < commonProb + rareProb) return 'rare';
      return 'epic';
    }

    function drawLives() {
      const lifeWidth = 10;  // Width of each life rectangle
      const lifeHeight = 30; // Height of each life rectangle (3 times the width)
      const spacing = 5;     // Space between life rectangles
      const startX = document.getElementById('livesDisplay').getBoundingClientRect().right + 30;     // Starting X position for the first life
      const startY = canvas.height - 40; // Y position for lives, 40 pixels from the bottom
      // console.log(startX);

      ctx.fillStyle = 'green';

      if (currentMode === GameModes.COOP) {
        // Draw lives for Player 1
        for (let i = 0; i < ship.lives; i++) {
          const x = startX + (lifeWidth + spacing) * i;
          ctx.fillRect(x, startY, lifeWidth, lifeHeight);
        }

        // Draw lives for Player 2
        const player2StartX = canvas.width - startX - (lifeWidth + spacing) * ship2.lives;
        for (let i = 0; i < ship2.lives; i++) {
          const x = player2StartX + (lifeWidth + spacing) * i;
          ctx.fillRect(x, startY, lifeWidth, lifeHeight);
        }

        // Update HTML display
        document.getElementById('livesDisplay').textContent = `P1 Health: ${ship.lives} | P2 Health: ${ship2.lives}`;
      } else {
        // Single player mode
        for (let i = 0; i < lives; i++) {
          const x = startX + (lifeWidth + spacing) * i;
          ctx.fillRect(x, startY, lifeWidth, lifeHeight);
        }

        // Update HTML display
        document.getElementById('livesDisplay').textContent = `Health: ${lives}`;
      }
    }


    function drawCoins() {
      ctx.fillStyle = 'white';
      ctx.font = '20px Press Start 2P';
      ctx.textAlign = 'left';
      let coinmessage = 'Coins: ' + coins;
      if (isMobile())
        coinmessage = coinmessage + '    tap for store';
      else
        coinmessage = coinmessage + "    'b' for store";

      ctx.fillText(coinmessage, 20, canvas.height - 30);
    }

    // function drawDrone() {
    //   ctx.save();
    //   ctx.translate(drone.x, drone.y);
    //   ctx.rotate(drone.direction);
    //   ctx.beginPath();
    //   ctx.moveTo(0, -drone.size);
    //   ctx.lineTo(-drone.size, drone.size);
    //   ctx.lineTo(drone.size, drone.size);
    //   ctx.closePath();
    //   ctx.fillStyle = 'cyan';
    //   ctx.fill();
    //   ctx.restore();

    //   // Draw drone lasers
    //   ctx.fillStyle = 'cyan';
    //   for (let i = 0; i < drone.lasers.length; i++) {
    //     let laser = drone.lasers[i];
    //     ctx.fillRect(laser.x - 1, laser.y - 1, 2, 2);
    //   }
    // }

    function saveTimeTaken(timeTaken) {
      localStorage.setItem('timeTaken', timeTaken);
    }

    function getTimeTaken() {
      return localStorage.getItem('timeTaken');
    }

    let timeTaken = 0;

    function endGame() {
      // Stop the game loop and background music

      document.getElementById('loginContainer').style.display = 'block';
      document.getElementById('userInfo').style.display = 'block';

      clearInterval(gameLoop);
      backgroundMusic.pause(); // Stop the background music
      gameEndTime = new Date();
      resetShip();

      // Calculate the time taken and save it
      timeTaken = gameEndTime - gameStartTime; // Time in milliseconds
      saveTimeTaken(timeTaken); // Save the time taken to local storage

      console.log("this run: " + timeTaken);
      score = Math.floor(score * modeScoreMultiplier); // Ensure score is a whole number

      // Calculate top six weapons by damage
      const topSixWeapons = Object.entries(damageReport)
        .filter(([weapon, damage]) => damage > 0) // Only include weapons with damage
        .sort((a, b) => b[1] - a[1])
        .slice(0, 6)
        .map(([weapon, damage]) => ({ weapon, damage }));

      const gameData = {
        score: score,
        topWeapons: topSixWeapons
      };

      saveUserScore(userId, gameId, gameData);

      // Load and display the leaderboard
      loadLeaderboard(gameId, currentMode);

      // Update achievements and handle end game server logic
      const { newlyUnlockedAchievements, newlyUnlockedWeapons } = updateAchievementsAtEnd();

      // Get three random affordable upgrades
      // const affordableUpgrades = getRandomAffordableUpgrades(coins);

      // Display the end game screen
      displayEndGameScreen(topSixWeapons, newlyUnlockedAchievements, newlyUnlockedWeapons);
    }
    function displayEndGameScreen(topWeapons, newlyUnlockedAchievements, newlyUnlockedWeapons, affordableUpgrades) {
      const endScreen = document.getElementById('endScreen');
      const waveElement = document.getElementById('wave');
      const scoreElement = document.getElementById('score');
      const asteroidsDestroyedElement = document.getElementById('asteroidsDestroyed');
      const currentCoinsElement = document.getElementById('currentCoins');
      const damageReportList = document.getElementById('damageReportList');
      const unlockedWeaponsList = document.getElementById('unlockedWeaponsList');
      const newAchievementsList = document.getElementById('newAchievementsList');
      const achievementSound = unlockSound;
      // document.getElementById('achievementSound');

      // Set game stats
      if (currentMode === GameModes.ENDLESS_SLOW) {
        waveElement.textContent = `Waves Survived: ${wave}`;
      } else {
        waveElement.textContent = `Wave: ${wave}`;
      }

      if (currentMode === GameModes.COOP) {
        const totalScore = ship.score + ship2.score;
        score = totalScore; // Set the total score for saving to leaderboard
        scoreElement.textContent = `Total Score: ${totalScore} (P1: ${ship.score}, P2: ${ship2.score})`;
      } else {
        scoreElement.textContent = `Score: ${score}`;
      }

      asteroidsDestroyedElement.textContent = `Asteroids Destroyed: ${asteroidsKilled}`;

      // Clear and set damage report
      damageReportList.innerHTML = '';
      const weaponDPM = calculateWeaponDPM();
      topWeapons.forEach(({ weapon, damage }) => {
        const weaponName = damageReportMapping[weapon];
        const weaponInfo = weapons.find(w => w.name === weaponName);
        if (weaponInfo) {
          const li = document.createElement('li');
          li.style.display = 'flex';
          li.style.alignItems = 'center';

          const icon = document.createElement('div');
          icon.classList.add('weaponClassIcon', weaponInfo.icon);
          icon.style.width = '24px';
          icon.style.height = '24px';
          icon.style.marginRight = '10px';

          const text = document.createElement('span');
          text.textContent = `${weaponInfo.name}: ${damage} (DPM: ${weaponDPM[weapon]})`;

          li.appendChild(icon);
          li.appendChild(text);
          damageReportList.appendChild(li);
        }
      });

      // Clear and set recently unlocked weapons
      unlockedWeaponsList.innerHTML = '';
      newlyUnlockedWeapons.forEach(weaponName => {
        const weaponInfo = weapons.find(w => w.name === weaponName);
        if (weaponInfo) {
          const li = document.createElement('li');
          li.style.display = 'flex';
          li.style.alignItems = 'center';

          const icon = document.createElement('div');
          icon.classList.add('weaponClassIcon', weaponInfo.icon);
          icon.style.width = '24px';
          icon.style.height = '24px';
          icon.style.marginRight = '10px';

          const text = document.createElement('span');
          text.textContent = weaponInfo.name;

          li.appendChild(icon);
          li.appendChild(text);
          unlockedWeaponsList.appendChild(li);
        }
      });

      // Clear and set achievements
      newAchievementsList.innerHTML = '';
      function displayAchievementsSequentially(index) {
        if (index >= newlyUnlockedAchievements.length) return;

        const achievement = newlyUnlockedAchievements[index];
        const li = document.createElement('li');
        li.textContent = achievement;
        li.classList.add('flash'); // Add the flashing animation class
        newAchievementsList.appendChild(li);

        achievementSound.play();

        // Remove the flash class after the animation duration (1 second)
        setTimeout(() => {
          li.classList.remove('flash');
          displayAchievementsSequentially(index + 1); // Display the next achievement
        }, 1000); // Adjust the duration as needed
      }

      displayAchievementsSequentially(0); // Start displaying achievements from the first one

      // Show the end screen
      endScreen.style.display = 'flex';
      levelUpModal.style.display = 'none';
    }


    function saveUserUpgrades(userId, gameId, data) {
      // Example function to save user upgrades and coins to the server
      fetch(`/api/saveUserUpgrades?userId=${userId}&gameId=${gameId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
      })
        .then(response => response.json())
        .then(data => {
          console.log('User upgrades saved successfully:', data);
        })
        .catch(error => {
          console.error('Error saving user upgrades:', error);
        });
    }


    function saveUserUpgrades(userId, gameId, data) {
      // Example function to save user upgrades and coins to the server
      fetch(`/ api / saveUserUpgrades ? userId = ${userId}& gameId=${gameId} `, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
      })
        .then(response => response.json())
        .then(data => {
          console.log('User upgrades saved successfully:', data);
        })
        .catch(error => {
          console.error('Error saving user upgrades:', error);
        });
    }


    function calculateWeaponDPM() {
      const weaponDPM = {};
      const endTime = Date.now();
      damageReportStartTimes.lasers = gameStartTime;

      Object.keys(damageReport).forEach(weapon => {
        const activeTime = (endTime - damageReportStartTimes[weapon]) / 60000; // Time in minutes
        weaponDPM[weapon] = activeTime > 0 ? (damageReport[weapon] / activeTime).toFixed(2) : 0;
      });

      return weaponDPM;
    }

    function drawDamageReport() {
      ctx.fillStyle = 'white';
      ctx.font = '14px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(`Damage Report: `, 20, canvas.height - 340);

      const weaponDPM = {};
      const endTime = Date.now();
      damageReportStartTimes.lasers = gameStartTime;

      Object.keys(damageReport).forEach(weapon => {
        const activeTime = (endTime - damageReportStartTimes[weapon]) / 60000; // Time in minutes
        weaponDPM[weapon] = activeTime > 0 ? (damageReport[weapon] / activeTime).toFixed(2) : 0;
      });

      let yOffset = canvas.height - 320;
      Object.keys(damageReport).forEach(weapon => {
        if (damageReport[weapon] > 0) {
          yOffset += 20;
          ctx.fillText(`${weapon.charAt(0).toUpperCase() + weapon.slice(1)}: ${damageReport[weapon]} (DPM: ${weaponDPM[weapon]})`, 20, yOffset);
        }
      });
    }




    let fourthUpgradeUnlocked = false;
    const levelUpModal = document.getElementById('levelUpModal');
    let lastLevelUp = Date.now();

    function levelUp() {
      level++;
      console.log()
      let prevLevelUp = lastLevelUp;
      lastLevelUp = Date.now();

      console.log(lastLevelUp - prevLevelUp);
      xp = 0;  // Reset XP
      xpToNextLevel = Math.floor(xpToNextLevel * levelUpXPMultiplier); // Increase XP required for next level
      updateXPBar();

      // Generate three random upgrades
      let upgradesToRetrieve = 3;
      if (fourthUpgradeUnlocked)
        upgradesToRetrieve++;

      const upgrades = getRandomUpgrades(upgradesToRetrieve);

      // Display the level-up modal
      document.getElementById('upgrade1').textContent = `1. ${upgrades[0]} `;
      document.getElementById('upgrade2').textContent = `2. ${upgrades[1]} `;
      document.getElementById('upgrade3').textContent = `3. ${upgrades[2]} `;
      if (fourthUpgradeUnlocked) {
        document.getElementById('upgrade4').style.display = `block`;
        document.getElementById('upgrade4').textContent = `4. ${upgrades[3]} `;
      }

      mostRecentUpgradeApplied = false;
      levelUpModal.style.display = 'block';

      // Store upgrades in a global variable for later use
      window.levelUpgrades = upgrades;

      // Pause the game
      clearInterval(gameLoop);
      isPaused = true;

      invincible = true;
      invincibilityTimer = invincibilityDuration;
    }



    function countTechnologies() {
      let count = 0;

      // These are all the achievements that have a specific weapon unlock assigned
      if (Achievements.reach_wave_2.reached) count++;
      if (Achievements.reach_wave_5.reached) count++;
      if (Achievements.reach_wave_10.reached) count++;
      if (Achievements.reach_wave_20.reached) count++;
      if (Achievements.complete_normal_mode.reached) count++;
      if (Achievements.acid_bomb_damage.reached) count++;
      if (Achievements.destroy_100_asteroids.reached) count++;
      if (Achievements.kill_5_aliens.reached) count++;
      if (Achievements.kill_15_aliens.reached) count++;
      if (Achievements.kill_50_aliens.reached) count++;
      if (Achievements.no_lives_lost.reached) count++;
      if (Achievements.death_ray_damage.reached) count++;
      if (Achievements.complete_meteor_normal_mode.reached) count++;
      if (Achievements.complete_meteor_hard_mode.reached) count++;
      if (Achievements.complete_planet_normal_mode.reached) count++;
      if (Achievements.complete_planet_hard_mode.reached) count++;
      if (Achievements.complete_hard_mode.reached) count++;
      if (Achievements.complete_hero_mode.reached) count++;
      if (Achievements.drone_damage.reached) count++;
      if (Achievements.laser_damage.reached) count++;
      if (Achievements.alien_megaboss_killed.reached) count++;
      // if (Achievements.alien_supermegaboss_killed.reached) count++;


      // Check the conditions of each ship
      for (const ship in ships) {
        if (ships.hasOwnProperty(ship)) {
          if (ships[ship].condition()) count++;
        }
      }

      return count;
    }
    let damageBooster = 0;



    function drawCooldownIndicator(x, y, radius, cooldown, maxCooldown) {
      if (cooldown <= 0) return;

      const startAngle = -Math.PI / 2; // Start at the top
      const endAngle = startAngle + (2 * Math.PI * (1 - cooldown / maxCooldown));

      ctx.save();
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(x, y, radius, startAngle, endAngle);
      ctx.stroke();
      ctx.restore();
    }



    function getUpgradeCount(weaponClass) {
      switch (weaponClass) {
        case 'explosive':
          return ship.explosiveLaserLevel;
        case 'turret':
          return turretUpgrades.range + turretUpgrades.fireRate + turretUpgrades.damage - 2;
        case 'drone':
          return droneUpgrades.laserInterval + droneUpgrades.damageLevel; // Assuming this is the main upgrade for drones
        case 'sonic':
          return sonicBlast.rangeLevel + sonicBlast.damageLevel + sonicBlast.cooldownLevel - 2; // Example calculation
        case 'bomberdrone':
          return bomberDroneUpgrades.speed + bomberDroneUpgrades.bombRadiusLevel + bomberDroneUpgrades.bombDamage - 3;
        case 'deathray':
          return deathRayUpgrades.length + deathRayUpgrades.width + deathRayUpgrades.cooldown - 2;
        case 'acid':
          return acidBombUpgrades.duration + acidBombUpgrades.cooldown + acidBombUpgrades.size - 2;
        case 'freeze':
          return freezeEffectUpgrades.duration + freezeEffectUpgrades.cooldown - 1;
        case 'boomerang':
          return boomerangUpgrades.speed + boomerangUpgrades.damage - 1;
        case 'nanoswarm':
          return nanoswarmUpgrades.speed + nanoswarmUpgrades.damage + nanoswarmUpgrades.cooldown - 2;
        case 'flamethrower':
          return flamethrowerUpgrades.range + flamethrowerUpgrades.damage + flamethrowerUpgrades.cooldown - 2;
        case 'chainlightning':
          return chainLightningUpgrades.range + chainLightningUpgrades.damage + chainLightningUpgrades.bounces + chainLightningUpgrades.cooldown - 3;
        case 'explosiverocket':
          return explosiveRocketUpgrades.damage + explosiveRocketUpgrades.radius + explosiveRocketUpgrades.cooldown - 2;

        default:
          return 0;
      }
    }



    function updateCoinsDisplay() {
      coinsDisplay.textContent = coins;
    }


    function isColliding(obj1, obj2) {
      if (obj1.radius) {
        // Circular collision detection for sonic blast wave
        let dx = obj1.x - obj2.x;
        let dy = obj1.y - obj2.y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        return distance < obj1.radius + obj2.size;
      } else {
        // Original collision detection
        let dx = obj1.x - obj2.x;
        let dy = obj1.y - obj2.y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        return distance < (obj1.size || 1) + obj2.size;
      }
    }


    function drawPixelatedExplosion(x, y, size) {
      const canvas = document.createElement('canvas');
      // const ctx = canvas.getContext('2d');
      const pixelSize = 4; // Adjust pixel size to your preference

      canvas.width = size;
      canvas.height = size;

      // Draw explosion on the off-screen canvas
      ctx.fillStyle = 'orange';
      ctx.beginPath();
      ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
      ctx.fill();

      // Get the image data
      const imageData = ctx.getImageData(0, 0, size, size);

      // Create a new canvas for pixelated effect
      const pixelCanvas = document.createElement('canvas');
      const pixelCtx = pixelCanvas.getContext('2d');

      pixelCanvas.width = size;
      pixelCanvas.height = size;

      // Draw pixelated effect
      for (let y = 0; y < size; y += pixelSize) {
        for (let x = 0; x < size; x += pixelSize) {
          const pixelIndex = (y * size + x) * 4;
          const r = imageData.data[pixelIndex];
          const g = imageData.data[pixelIndex + 1];
          const b = imageData.data[pixelIndex + 2];
          const a = imageData.data[pixelIndex + 3];

          pixelCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a / 255})`;
          pixelCtx.fillRect(x, y, pixelSize, pixelSize);
        }
      }

      // Draw the pixelated explosion on the main canvas
      ctx.drawImage(pixelCanvas, 0, 0);

      // Draw the pixelated canvas onto the game canvas
      ctx.drawImage(canvas, x - size / 2, y - size / 2);
    }

    // Usage
    // drawPixelatedExplosion(100, 100, 64);


    function drawScore() {
      const secondsUntilNextWave = Math.ceil(spawnTimer);

      document.getElementById('waveCounter').textContent = `Wave: ${wave} ${secondsUntilNextWave}s`;

      if (!isMobile()) {
        // document.getElementById('controlsInfo').textContent = "[m]usic sou[n]d [v]olume [p]ause [i]nfo";
        document.getElementById('controlsInfo').textContent = "[m]usic sou[n]d [p]ause [i]nfo";

      } else {
        document.getElementById('controlsInfo').textContent = '';
      }
    }



    // Draw wave message
    function drawWaveMessage() {
      ctx.fillStyle = 'white';
      ctx.font = '40px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Wave ' + wave, canvas.width / 2, canvas.height / 2);
    }

    let chanceForSmallAsteroid = 3;
    let chanceForVerySmallAsteroid = 1;
    let chanceForHardenedAsteroid = 5;
    let chanceForVeryHardenedAsteroid = 2; // Example chance for very hardened asteroid
    let chanceForMegaHardenedAsteroid = 1; // Example chance for mega hardened asteroid

    function createSmallerAsteroids(x, y, size, speed, hitpoints) {
      const baseAngles = [0, Math.PI / 2, Math.PI, (3 * Math.PI) / 2];
      const speedMultiplier = 0.2; // Decrease speed for smaller asteroids
      const newSize = size / 2; // New size for smaller asteroids

      for (let i = 0; i < 3; i++) {
        const angleVariation = (Math.random() - 0.5) * 0.7; // Random variation between -0.1 and 0.1 radians
        const angle = baseAngles[i] + angleVariation;

        let asteroid = {
          x: x,
          y: y,
          size: newSize,
          speed: speed * speedMultiplier,
          dx: Math.cos(angle) * speed * speedMultiplier,
          dy: Math.sin(angle) * speed * speedMultiplier,
          hitpoints: hitpoints,
          initialHitpoints: hitpoints, // Store the initial hitpoints
          color: 'gray'
        };
        asteroids.push(asteroid);
      }
    }

    const asteroidImages = [];



    const droneImages = {
      regularDrone: 'icons/laserdrone.png',
      bomberDrone: 'icons/bomberdrone.png',
      nanoDrone: 'icons/nanodrone.png',
    };

    function preloadDroneImages() {
      for (const droneType in droneImages) {
        const image = new Image();
        image.src = droneImages[droneType];
        droneImages[droneType] = image;
      }
    }

    // Call the preloadDroneImages function before starting the game
    preloadDroneImages();

    function showArrow(side) {
      const leftArrow = document.getElementById('leftArrow');
      const rightArrow = document.getElementById('rightArrow');

      if (side === 'left') {
        leftArrow.style.display = 'block';
        rightArrow.style.display = 'none';
      } else {
        leftArrow.style.display = 'none';
        rightArrow.style.display = 'block';
      }

      setTimeout(() => {
        leftArrow.style.display = 'none';
        rightArrow.style.display = 'none';
        createAsteroids(side);
      }, 700);
    }




    // Function to create area damage
    function createAreaDamage(x, y, radius, damage = 1) {
      let totalDamage = 0;
      for (let i = asteroids.length - 1; i >= 0; i--) {
        let asteroid = asteroids[i];
        let dx = asteroid.x - x;
        let dy = asteroid.y - y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < radius) {
          let actualDamage = Math.min(damage + damageBooster, asteroid.hitpoints);
          asteroid.hitpoints -= actualDamage;
          totalDamage += actualDamage;

          // if (asteroid.hitpoints <= 0) {
          //   processAsteroidDeath(asteroid);
          //   asteroids.splice(i, 1);
          // }

          coins += actualDamage * 15;
          increaseXP(actualDamage * 15);
          score += actualDamage * 50;
        }
      }
      return totalDamage;
    }


    function increaseXP(amount) {

      const currTimeInMS = Date.now();
      if (xp >= (xpToNextLevel / 1)) {
        if (lastLevelUp + 1000 > currTimeInMS) {
          amount *= 0.05;
        } else if (lastLevelUp + 3000 > currTimeInMS) {
          amount *= .1;
        } else if (lastLevelUp + 6000 > currTimeInMS) {
          amount *= .2;
        }
      }
      xp += amount;
      document.getElementById('xpBarContainer').style.display = 'block';

      updateXPBar();

      if (xp >= xpToNextLevel && currTimeInMS > (lastLevelUp + 5000)) {

        levelUp();
      }
    }

    function updateXPBar() {
      const xpBar = document.getElementById('xpBar');
      const xpPercentage = (xp / xpToNextLevel) * 100;
      xpBar.style.width = xpPercentage + '%';
    }



    // Function to get a random shade of orange
    function getRandomOrangeShade() {
      const shades = ['#FF4500', '#FF6347', '#FF8C00', '#FFA500', '#FF7F50'];
      return shades[Math.floor(Math.random() * shades.length)];
    }

    function getRandomBlueShade() {
      const shades = ['#1E90FF', '#00BFFF', '#87CEFA', '#4682B4', '#5F9EA0'];
      return shades[Math.floor(Math.random() * shades.length)];
    }

    function getRandomPurpleShade() {
      const shades = ['#800080', '#8B008B', '#9370DB', '#9400D3', '#9932CC', '#BA55D3', '#DA70D6', '#DDA0DD', '#EE82EE', '#FF00FF'];
      return shades[Math.floor(Math.random() * shades.length)];
    }

    function getRandomRedShade() {
      const shades = ['#FF0000', '#DC143C', '#B22222', '#FF6347', '#FF4500'];
      return shades[Math.floor(Math.random() * shades.length)];
    }

    // Draw the explosions on the canvas
    function drawExplosions() {
      for (let i = 0; i < explosions.length; i++) {
        let explosion = explosions[i];
        ctx.fillStyle = explosion.color;
        ctx.globalAlpha = explosion.alpha;
        ctx.beginPath();
        ctx.arc(explosion.x, explosion.y, explosion.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        explosion.alpha -= explosion.alphaDecay;
        if (explosion.alpha <= 0) {
          explosions.splice(i, 1);
          i--;
        }
      }
    }

    // Update explosions with random alpha decay
    function updateExplosions() {
      for (let i = 0; i < explosions.length; i++) {
        explosions[i].size += 1;
        explosions[i].alpha -= explosions[i].alphaDecay;
        if (explosions[i].alpha <= 0) {
          explosions.splice(i, 1);
          i--;
        }
      }
    }

    // Draw explosions with random colors
    function drawExplosions() {
      for (let i = 0; i < explosions.length; i++) {
        ctx.save();
        ctx.globalAlpha = explosions[i].alpha;
        ctx.beginPath();
        ctx.arc(explosions[i].x, explosions[i].y, explosions[i].size, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fillStyle = explosions[i].color;
        ctx.fill();
        ctx.restore();
      }
    }

    // Reset ship position
    function resetShip(center = true) {
      if (center) {
        ship.x = canvas.width / 2;
        ship.y = canvas.height / 2; //TODO: somehow not working?
      }
      ship.velocityX = 0;
      ship.velocityY = 0;
      ship.speed = 0;
    }


    let explosiveRockets = [];





    let keys = {};
    let isPaused = false;
    let loginFormOpen = false;



    function handleKeyDown(event) {
      keys[event.key] = true;

      if (event.key === 'ArrowLeft' || event.key === 'ArrowRight' ||
        event.key === 'ArrowUp' || event.key === 'ArrowDown' || event.key === ' ') {
        event.preventDefault();
      }



      if (document.getElementById('loginPopup').style.display == 'none') {

        // Player 2 controls
        if (event.key === 'a' || event.key === 'd' ||
          event.key === 'w' || event.key === 's' || event.key === 'q') {
          event.preventDefault();
        }

        // if (event.key === ' ') { // Space bar
        //   if (!isPaused && document.getElementById('spinButton').style.display !== 'none') {
        //     startRoulette();
        //   }
        // } else

        if (event.key === 'Enter') {

          if (document.getElementById('rouletteContainer').style.display != 'none') {

            const okButton = document.querySelector('#upgradeDisplay button');
            console.log(okButton);
            if (okButton) {
              okButton.click();
            } else {

              startRoulette();
            }
          }
        }

        if (event.key === 'i' || event.key === 'I') {
          // console.log("toggle1");
          toggleWeaponInfo();
        } else if (event.key === 'p' || event.key === 'P') {

          if (isPaused) {

            clearInterval(gameLoop);
            gameLoop = setInterval(update, 1000 / 60); // Resume game loop
            isPaused = false;

          }
          else {

            if (document.getElementById('rouletteContainer').style.display == 'none' && document.getElementById('endScreen').style.display == 'none') {

              clearInterval(gameLoop);
              isPaused = true;

            }


          }

        } else if (event.key === 'm') {

          toggleMusic();
        } else if (event.key === 'n') {

          toggleSound();

        } else if (event.key === 'u' || event.key === 'U') {
          // for testing new features
          clearInterval(gameLoop);
          isPaused = true;
          // drawPlanetx(); // Draw the planet
          document.getElementById('rouletteContainer').style.display = 'block';
          // startRoulette();

        } else if (event.key === 'v' || event.key === 'V') {

          toggleVolumeScreen();
        }


        if (document.getElementById('levelUpModal').style.display === 'block') {
          if (event.key === '1') {
            selectUpgrade(1);
          } else if (event.key === '2') {
            selectUpgrade(2);
          } else if (event.key === '3') {
            selectUpgrade(3);
          } else if (fourthUpgradeUnlocked && event.key === '4') {
            selectUpgrade(4);
          }


        }

      }


    }

    function handleKeyUp(event) {
      keys[event.key] = false;
    }

    let toggleOff = false;
    let toggleSoundOff = false;

    function toggleMusic() {
      if (!toggleOff)
        toggleOff = true;
      backgroundMusic.pause();

      if (isMusicPlaying) {
        backgroundMusic.pause();
      } else {
        backgroundMusic.play();
      }
      isMusicPlaying = !isMusicPlaying;
    }

    function toggleSound() {
      if (!toggleSoundOff)
        toggleSoundOff = true;
      else
        toggleSoundOff = false;

    }






    window.addEventListener('resize', resizeCanvas);

    joystick.addEventListener('touchstart', (e) => {
      isTouchingJoystick = true;
      joystickStartX = e.touches[0].clientX;
      joystickStartY = e.touches[0].clientY;
    });


    joystick.addEventListener('touchmove', (e) => {
      if (isTouchingJoystick) {
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        const deltaX = touchX - joystickStartX;
        const deltaY = touchY - joystickStartY;

        // Calculate angle and distance from the center
        const angle = Math.atan2(deltaY, deltaX);
        const distance = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), 50); // Limit the joystick handle movement

        // Update joystick handle position
        joystickHandle.style.transform = `translate(${distance * Math.cos(angle)}px, ${distance * Math.sin(angle)}px)`;

        // Update ship rotation and speed based on joystick movement
        ship.rotation = angle * (180 / Math.PI); // Convert radians to degrees
        ship.speed = Math.min(distance / 20, ship.maxSpeed); // Adjust speed based on distance, ensure it doesn't exceed maxSpeed

        e.preventDefault();
      }
    });

    joystick.addEventListener('touchend', () => {
      isTouchingJoystick = false;
      ship.speed = 0;
      joystickHandle.style.transform = 'translate(-50%, -50%)'; // Reset joystick handle position
    });

    restartButton.addEventListener('click', () => {
      // restartButton.style.display = 'none';
      document.getElementById('endScreen').style.display = 'none';
      startScreen.style.display = 'block';

      resetShip();
      gravityStrength = 0;
      meteorMode = false;
      planetMode = false;
      fourthUpgradeUnlocked = false;
      doubleTurret = false;
      tripleTurret = false;
      alienLasers = [];
      activeMegaUpgrades = [];

      turret = {
        x: 0,
        y: 0,
        size: 10,
        rotationSpeed: 2,
        fireInterval: 120,
        fireTimer: 0,
        range: 400,
        damage: 3,
        color: 'cyan',
        lasers: [] // Initialize the turret's lasers array
      };

      let count = countTechnologies();
      const technologiesCountElement = document.getElementById('technologiesCount');
      technologiesCountElement.textContent = `You have unlocked ${count} of 42 technologies`;
      document.getElementById('technologiesCount').style.display = 'block';
      document.getElementById('shipType').style.display = 'block';

      lives = 3;
      score = 0;
      wave = 1;
      asteroidsKilled = 0;
      aliensKilled = 0;
      fourthUpgradeUnlocked = false;

      // Reset coins and XP
      coins = 0;
      level = 1;
      xpToNextLevel = 300;
      xp = 0;
      updateXPBar();

      // Reset asteroids and drones
      asteroids = [];
      drones = [];
      aliens = [];
      alien = null;
      swarmingAliens = [];
      superbossAlien = null;
      alienLasers = [];
      droppedGems = [];

      // Reset turret upgrades
      turret.bought = false;
      // Reset active weapon classes
      activeWeaponClasses = [];


      level = 1;
      xp = 0;

      acidBomb = {
        cooldown: 300,
        timer: 0,
        duration: 300, // Duration the acid effect lasts (5 seconds at 60 FPS)
        damagePerSecond: 1,
        size: 50,
        activeBombs: [],
        activeAreas: []
      };

      acidBombUpgrades = {
        duration: 1,
        cooldown: 1,
        size: 1
      };

      boomerang = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        size: 10,
        speed: 2,
        damage: 1,
        dx: 3,
        dy: 3,
        active: false
      };

      boomerangUpgrades = {
        speed: 1,
        damage: 1
      };

      nanoswarm = {
        cooldown: 300,
        timer: 0,
        speed: 2,
        damage: 5,
        activeMissiles: []
      };

      nanoswarmUpgrades = {
        speed: 1,
        damage: 1,
        cooldown: 1
      };

      freezeEffect = {
        cooldown: 600, // Cooldown period for freeze effect (10 seconds at 60 FPS)
        timer: 0,
        duration: 300, // Duration the freeze effect lasts (5 seconds at 60 FPS)
        active: false,
        remainingDuration: 0
      };

      freezeEffectUpgrades = {
        duration: 1,
        cooldown: 1
      };

      damageReport = {
        lasers: 0,
        explosive: 0,
        drones: 0,
        turret: 0,
        sonicBlast: 0,
        bomberDrones: 0,
        deathRay: 0,
        acid: 0,
        freeze: 0,
        boomerang: 0,
        nano: 0

      };


      deathRay = {
        length: 1000,
        width: 40,
        cooldown: 300,
        timer: 0
      };


      deathRayActive = false;

      deathRayUpgrades = {
        length: 1,
        width: 1,
        cooldown: 1
      };



      ship = {
        x: canvas.width / 2,
        y: canvas.height - 50,
        size: 20,
        speed: 0,
        acceleration: 0.15,
        deceleration: 0.96,
        maxSpeed: 3,
        rotation: 0,
        rotationSpeed: 1.7,
        lasers: [],
        velocityX: 0,
        velocityY: 0,
        laserLevel: 2,
        weaponSlots: 5,
        upgradeSlots: 2,
        accelerationLevel: 1,
        rotationSpeedLevel: 1,
        maxBulletsLevel: 1,
        explosiveLaserLevel: 0,
        laserCooldown: 30,
        laserTimer: 0,
        laserCooldownLevel: 1,

      };

      drone = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        size: 10,
        speed: 0.0001,
        direction: Math.random() * Math.PI * 2,
        lasers: [],
        laserSpeed: 3,
        laserInterval: 80, // Fire lasers every 120 frames (2 second)
        laserTimer: 0
      };

      turret = {
        x: 0,
        y: 0,
        size: 10,
        rotationSpeed: 2,
        fireInterval: 120,
        fireTimer: 0,
        range: 400,
        damage: 3,
        color: 'cyan',
        lasers: [] // Initialize the turret's lasers array
      };

      turretUpgrades = {
        range: 1,
        fireRate: 1,
        damage: 1
      };

      sonicBlast = {
        cooldown: 300, // Cooldown time in frames (5 seconds at 60 FPS)
        timer: 0, // Current cooldown timer
        range: 120, // Range of the sonic blast
        speed: 2, // Speed of the sonic blast wave
        damage: 1, // Damage dealt by the sonic blast
        waves: [], // Array to store the active sonic blast waves
        rangeLevel: 1,
        damageLevel: 1,
        cooldownLevel: 1

      };

      // Reset game state
      gameOver = false;
      invincible = true;
      invincibilityTimer = invincibilityDuration;
      // document.getElementById('leaderboard-container').style.display = 'none';

      // Reset spawn variables
      spawnTimer = spawnCooldown;
      chanceForSmallAsteroid = 3;
      chanceForVerySmallAsteroid = 1;
      chanceForHardenedAsteroid = 5;
      chanceForVeryHardenedAsteroid = 2;

      // Reset ship position
      // resetShip();

      bomberDrones = [];


      // bomberDrones = [];
      bomberDroneUpgrades = {
        speed: 1,
        bombRadiusLevel: 1,
        bombRadius: 50,
        bombDamage: 2
      };

      chainLightning = {
        cooldown: 300, // Cooldown time in frames
        timer: 0, // Current cooldown timer
        range: 200, // Range of the chain lightning
        damage: 5, // Damage dealt per hit
        bounces: 2, // Number of bounces
        active: false // Flag to track if the chain lightning is active
      };

      chainLightningUpgrades = {
        range: 1,
        damage: 1,
        bounces: 1,
        cooldown: 1
      };


      // Start a new game
      // createAsteroids();
      // startGame();
    });







    function toggleWeaponInfo() {
      const weaponInfoDiv = document.getElementById('weaponInfo');

      // console.log(weaponInfoDiv);
      weaponInfoDiv.style.display = weaponInfoDiv.style.display === 'none' ? 'block' : 'none';
      // console.log("toggle2");
      if (weaponInfoDiv.style.display === 'none') {
        clearInterval(gameLoop);
        gameLoop = setInterval(update, 1000 / 60);
      } else {
        clearInterval(gameLoop);

      }

      // Won't place nicely together with above
      // if (isPaused) {

      //   gameLoop = setInterval(update, 1000 / 60); // Resume game loop
      //   isPaused = false;

      // } else {

      //   clearInterval(gameLoop);
      //   isPaused = true;

      // }


    }

    function loadWeaponInfo() {
      const weaponsContainer = document.getElementById('weaponsContainer');
      weaponsContainer.innerHTML = '';
      weapons.forEach(weapon => {
        const weaponDiv = document.createElement('div');
        weaponDiv.className = 'weapon';
        weaponDiv.innerHTML = `
            <div class="weapon-icon ${weapon.icon}"></div>
            <p><strong>${weapon.name}</strong></p>
            <p>${weapon.description}</p>
        `;
        weaponsContainer.appendChild(weaponDiv);
      });
    }
    function populateUpgrades() {
      const upgradesList = document.getElementById('upgradesList');
      upgradesList.innerHTML = '';

      megaUpgrades.forEach(upgrade => {
        const upgradeElement = document.createElement('div');
        upgradeElement.classList.add('upgrade');
        upgradeElement.style.opacity = upgrade.owned ? '1' : '0.5';

        const icon = document.createElement('img');
        icon.classList.add('upgrade-icon');
        icon.src = upgrade.icon;
        icon.alt = upgrade.name;
        upgradeElement.appendChild(icon);

        const description = document.createElement('span');
        description.classList.add('upgrade-info');

        description.textContent = upgrade.description;
        upgradeElement.appendChild(description);

        upgradesList.appendChild(upgradeElement);
      });
    }


    function populateAchievements() {
      const achievementsList = document.getElementById('achievementsList');
      achievementsList.innerHTML = '';

      // document.getElementById('normalButton').disabled = !Achievements.complete_easy_mode.reached;
      document.getElementById('hardButton').disabled = !Achievements.complete_normal_mode.reached;
      document.getElementById('heroButton').disabled = !Achievements.complete_hard_mode.reached;


      document.getElementById('meteorEasyButton').disabled = !Achievements.complete_normal_mode.reached;
      document.getElementById('meteorNormalButton').disabled = !Achievements.complete_meteor_easy_mode.reached;
      document.getElementById('meteorHardButton').disabled = !Achievements.complete_meteor_normal_mode.reached;
      document.getElementById('meteorHeroButton').disabled = !Achievements.complete_meteor_hard_mode.reached;

      document.getElementById('planetEasyButton').disabled = !Achievements.complete_meteor_normal_mode.reached;
      document.getElementById('planetNormalButton').disabled = !Achievements.complete_planet_easy_mode.reached;
      document.getElementById('planetHardButton').disabled = !Achievements.complete_planet_normal_mode.reached;
      document.getElementById('planetHeroButton').disabled = !Achievements.complete_planet_hero_mode.reached;

      console.log(Achievements);
      // console.log("pop");
      for (const key in Achievements) {
        if (Achievements.hasOwnProperty(key)) {
          // console.log("pop" + key);

          const achievement = Achievements[key];
          const achieved = achievement.reached || (achievement.damage && achievement.damage >= achievement.required);

          const achievementElement = document.createElement('div');
          achievementElement.classList.add('achievement');
          achievementElement.style.opacity = achieved ? '1' : '0.5';

          const icon = document.createElement('img');
          icon.src = achievement.icon;
          icon.alt = achievement.description;
          achievementElement.appendChild(icon);
          const description = document.createElement('span');
          description.textContent = achievement.description;
          achievementElement.appendChild(description);

          achievementsList.appendChild(achievementElement);
        }
      }

      let count = countTechnologies();
      const technologiesCountElement = document.getElementById('technologiesCount');
      let totalTechnologyCount = 0;
      totalTechnologyCount += 5; //ships
      totalTechnologyCount += 13; //weapons
      totalTechnologyCount += 7; //boosters
      totalTechnologyCount += 17; //upgrades
      technologiesCountElement.textContent = `${count} of ${totalTechnologyCount}  technologies unlocked`;

    }


    const Achievements = {
      reach_wave_2: { reached: false, icon: 'achievements/whitehat.png', description: 'Reach Wave 2' },
      reach_wave_5: { reached: false, icon: 'achievements/whitehat.png', description: 'Reach Wave 5' },
      // reach_wave_57: { reached: false, icon: 'achievements/whitehat.png', description: 'Reach Wave 7' },
      reach_wave_10: { reached: false, icon: 'achievements/angelcapitan.png', description: 'Reach Wave 10. Unlock Sonic Blast.' },
      // reach_wave_15: { reached: false, icon: 'achievements/insanecat.png', description: 'Reach Wave 15' },
      reach_wave_20: { reached: false, icon: 'achievements/keroaccat.png', description: 'Reach Wave 20. Unlock Boomerang.' },
      // reach_wave_25: { reached: false, icon: 'achievements/onthemoon.png', description: 'Reach Wave 25' },
      destroy_100_asteroids: { reached: false, icon: 'achievements/speedy.png', description: 'Destroy 100 Asteroids in One Game. Unlock Drone.' },
      // destroy_500_asteroids: { reached: false, icon: 'achievements/_5973.png', description: 'Destroy 500 Asteroids in One Game' },
      complete_easy_mode: { reached: false, icon: 'achievements/whitehat.png', description: 'Complete Easy Mode.' },
      complete_normal_mode: { reached: false, icon: 'achievements/insanecat.png', description: 'Normal Mode. Unlock Acid Bomb.' },
      acid_bomb_damage: { reached: false, damage: 0, required: 2500, icon: 'achievements/acid.png', description: 'Deal 2,500 Damage with Acid Bomb. Unlock Flamethrower.' },
      laser_damage: { reached: false, damage: 0, required: 2500, icon: 'achievements/deathray2.png', description: 'Deal 2,500 Damage with Laser. Unlock Explosive Laser.' },
      drone_damage: { reached: false, damage: 0, required: 1500, icon: 'achievements/storm_drone.png', description: 'Deal 1,500 Damage with Drone. Unlock Drone Army.' },
      explosive_laser_damage: { reached: false, damage: 0, required: 5000, icon: 'achievements/explosive.png', description: 'Deal 5,000 Damage with Explosive Laser' },
      death_ray_damage: { reached: false, damage: 0, required: 10000, icon: 'achievements/deathray.png', description: 'Deal 10,000 Damage with Death Ray. Unlock Extra Choice.' },
      no_lives_lost: { reached: false, icon: 'achievements/orpheus.png', description: 'Survived with No Lives Lost. Unlock Nano Swarm.' },
      complete_hard_mode: { reached: false, icon: 'achievements/explosion.png', description: 'Hard Mode. Unlock Explosive Rocket.' },
      complete_hero_mode: { reached: false, icon: 'achievements/cyberpunk.png', description: 'Hero Mode. Unlock Extra Life.' },
      kill_5_aliens: { reached: false, icon: 'achievements/aliensign.png', description: 'Kill 5 Aliens. Unlock Death Ray.' },
      kill_15_aliens: { reached: false, icon: 'achievements/aliensign.png', description: 'Kill 15 Aliens. Unlock Chain Lightning.' },
      kill_50_aliens: { reached: false, icon: 'achievements/aliensign.png', description: 'Kill 50 Aliens. Unlock Sonic Boomerang.' },
      complete_meteor_easy_mode: { reached: false, icon: 'achievements/meteor_one.png', description: 'Shower Easy Mode. Unlock Starhawk' },
      complete_meteor_normal_mode: { reached: false, icon: 'achievements/meteor_acid.png', description: 'Shower Normal Mode. Unlock Double Turret.' },
      complete_meteor_hard_mode: { reached: false, icon: 'achievements/meteor_small.png', description: 'Shower Hard Mode. Unlock Solar Phoenix .' },
      complete_meteor_hero_mode: { reached: false, icon: 'achievements/death_meteor.png', description: 'Shower Hero Mode. Unlock Quantum Striker' },
      complete_planet_easy_mode: { reached: false, icon: 'achievements/planet_medium.png', description: 'Planet Easy Mode.' },
      complete_planet_normal_mode: { reached: false, icon: 'achievements/storm_medium.png', description: 'Planet Normal Mode. Unlock Triple Turret.' },
      complete_planet_hard_mode: { reached: false, icon: 'achievements/onthemoon.png', description: 'Planet Hard Mode. Unlock Explosive Rocket.' },
      complete_planet_hero_mode: { reached: false, icon: 'achievements/planet_huge.png', description: 'Planet Hero Mode' },
      alien_megaboss_killed: { reached: false, icon: 'achievements/planet_huge.png', description: 'Killed Alien Megaboss. Mega unlock.' },
      alien_supermegaboss_killed: { reached: false, icon: 'achievements/planet_huge.png', description: 'Killed Alien SuperMegaBoss. Super Secret unlock.' },
      alien_octopus_killed: { reached: false, icon: 'achievements/planet_huge.png', description: 'Killed Vampire Alien Octopus. Super Mega Secret unlock.' },

    };

    let afterGameAchievements = null;

    function updateAchievementsAtEnd() {

      const newlyUnlockedAchievements = [];

      const newlyUnlockedWeapons = [];

      const addAchievement = (achievementKey) => {
        if (!Achievements[achievementKey].reached) {
          Achievements[achievementKey].reached = true;
          newlyUnlockedAchievements.push(Achievements[achievementKey].description);
        }
      };

      if (wave >= 2) addAchievement('reach_wave_2');
      if (wave >= 5) addAchievement('reach_wave_5');
      if (wave >= 10) addAchievement('reach_wave_10');
      if (wave >= 20) addAchievement('reach_wave_20');
      if (damageReport.acid >= Achievements.acid_bomb_damage.required) addAchievement('acid_bomb_damage');
      if (damageReport.explosive >= Achievements.explosive_laser_damage.required) addAchievement('explosive_laser_damage');
      if (asteroidsKilled >= 100) addAchievement('destroy_100_asteroids');
      if (lives === 3) addAchievement('no_lives_lost');

      const gameModeAchievements = [
        { key: 'complete_easy_mode', mode: GameModes.EASY },
        { key: 'complete_normal_mode', mode: GameModes.NORMAL },
        { key: 'complete_hard_mode', mode: GameModes.HARD },
        { key: 'complete_hero_mode', mode: GameModes.HERO },
        { key: 'complete_meteor_easy_mode', mode: GameModes.METEORSHOWEREASY },
        { key: 'complete_meteor_normal_mode', mode: GameModes.METEORSHOWERNORMAL },
        { key: 'complete_meteor_hard_mode', mode: GameModes.METEORSHOWERHARD },
        { key: 'complete_meteor_hero_mode', mode: GameModes.METEORSHOWERHERO },
        { key: 'complete_planet_easy_mode', mode: GameModes.PLANETEASY },
        { key: 'complete_planet_normal_mode', mode: GameModes.PLANETNORMAL },
        { key: 'complete_planet_hard_mode', mode: GameModes.PLANETHARD },
        { key: 'complete_planet_hero_mode', mode: GameModes.PLANETHERO }
      ];

      gameModeAchievements.forEach(({ key, mode }) => {
        if (currentMode === mode && wave >= 30) addAchievement(key);
      });

      if (damageReport.deathRay >= Achievements.death_ray_damage.required) addAchievement('death_ray_damage');
      if (damageReport.drones >= Achievements.drone_damage.required) addAchievement('drone_damage');
      if (damageReport.lasers >= Achievements.laser_damage.required) addAchievement('laser_damage');
      if (aliensKilled >= 5) addAchievement('kill_5_aliens');
      if (aliensKilled >= 15) addAchievement('kill_15_aliens');
      if (aliensKilled >= 50) addAchievement('kill_50_aliens');


      localStorage.setItem('achievements', JSON.stringify(Achievements));
      populateAchievements();

      // Determine newly unlocked weapons based on the achievements unlocked
      const achievementToWeaponMap = {
        'reach_wave_2': 'Bomber Drone',
        'reach_wave_5': 'Freeze Effect',
        'laser_damage': 'Explosive Laser',
        'reach_wave_10': 'Sonic Blast',
        'reach_wave_20': 'Boomerang',
        'complete_normal_mode': 'Acid Bomb',
        'destroy_100_asteroids': 'Drone',
        'kill_5_aliens': 'Death Ray',
        'complete_planet_hard_mode': 'Explosive Rocket',
        'kill_15_aliens': 'Chain Lightning',
        'kill_50_aliens': 'SonicBoomerang',
        'no_lives_lost': 'Nano Swarm',
        'acid_bomb_damage': 'Flamethrower'
      };

      newlyUnlockedAchievements.forEach(achievement => {
        if (achievement in achievementToWeaponMap) {
          newlyUnlockedWeapons.push(achievementToWeaponMap[achievement]);
        }
      });
      console.log(newlyUnlockedAchievements);
      console.log(newlyUnlockedWeapons);

      return { newlyUnlockedAchievements, newlyUnlockedWeapons };
    }

    window.onload = loadWeaponInfo;

    // for leaderboard and telegram API 
    let gameId = "InfiniteSpaceWar";








  </script>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>
  <script>

    let userId = "";
    const firebaseConfig = {
      apiKey: "AIzaSyCvgdn8c6D8RusKRr4vHAzFj1x4FNxrXVE",
      authDomain: "infinite-games-9c69e.firebaseapp.com",
      projectId: "infinite-games-9c69e",
      storageBucket: "infinite-games-9c69e.appspot.com",
      messagingSenderId: "602022483888",
      appId: "1:602022483888:web:f967a6c1cb236ae66ba875",
      measurementId: "G-9LE6E1BKZ7"
    };

    let starHawk = false;

    const shipSwitcher = document.getElementById('shipType');
    let currentShip = 'basic';
    let currentShipType = 'basic';

    // Draw the ship
    function drawShip() {
      if (!invincible || (invincibilityTimer % 20 < 10)) {
        ctx.save();
        ctx.translate(ship.x, ship.y);
        ctx.rotate(ship.rotation * Math.PI / 180);

        // Draw the current ship
        ships[currentShip].draw();

        ctx.restore();
      }
    }

    shipSwitcher.addEventListener('click', (event) => {
      console.log("switch");
      const shipNames = Object.keys(ships);
      let nextIndex = (shipNames.indexOf(currentShip) + 1) % shipNames.length;
      console.log(ships[shipNames[nextIndex]]);

      console.log(shipNames);
      console.log(nextIndex);

      // Find the next available ship based on the conditions
      while (!ships[shipNames[nextIndex]].condition()) {
        console.log(ships[shipNames[nextIndex]]);

        nextIndex = (nextIndex + 1) % shipNames.length;
      }
      console.log(nextIndex);

      currentShip = shipNames[nextIndex];
      console.log(currentShip);

      const shipData = ships[currentShip];
      console.log(shipData);


      shipSwitcher.innerHTML = `Ship type: ${shipData.name}`;

      console.log(shipSwitcher);

      // Update ship properties
      lives = shipData.lives;
      ship.laserLevel = shipData.laserLevel;
      ship.weaponSlots = shipData.weaponSlots;
      ship.upgradeSlots = shipData.upgradeSlots;

    });

    function pauseGame() {
      if (!isPaused) {
        clearInterval(gameLoop);
        isPaused = true;
      }
    }

    function resumeGame() {
      if (isPaused) {
        clearInterval(gameLoop);
        gameLoop = setInterval(update, 1000 / 60);
        isPaused = false;
      }
    }

  </script>
  <script type="module">

    // import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    // import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-analytics.js";
    // import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-analytics.js";
    import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged, createUserWithEmailAndPassword } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    // import { getFirestore, doc, getDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
    import { getFirestore, doc, updateDoc, arrayUnion, getDoc, setDoc, getDocs, collection } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";


    // Firebase configuration and initialization
    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);
    const auth = getAuth(app);
    const db = getFirestore(app);







    const loginLink = document.getElementById('login-link');
    const loginPopup = document.getElementById('loginPopup');
    const loginForm = document.getElementById('loginForm');
    const userInfo = document.getElementById('userInfo');
    const userNickname = document.getElementById('userNickname');
    const logoutLink = document.getElementById('logoutLink');
    const loginContainer = document.getElementById('loginContainer');
    const signupForm = document.getElementById('signup-form');


    async function saveInitialData(userId, email, nickname) {
      const initialData = {
        email: email,
        nickname: nickname,
        coins: 100,
        portfolio: {},
        portfolioHistory: []
      };
      await setDoc(doc(db, 'users', userId), initialData);
    }

    loginLink.addEventListener('click', (event) => {
      loginFormOpen = true;
      event.preventDefault();
      pauseGame();
      loginPopup.style.display = 'block';
    });

    loginForm.addEventListener('submit', (event) => {
      event.preventDefault();
      const email = document.getElementById('email').value;
      const password = document.getElementById('password').value;

      signInWithEmailAndPassword(auth, email, password)
        .then((userCredential) => {
          const user = userCredential.user;
          loadUserData(user.uid);
          loginPopup.style.display = 'none';
          loginFormOpen = false;
          resumeGame();
        })
        .catch((error) => {
          console.error('Error signing in:', error.message);
        });
    });

    signupForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const email = signupForm['signup-email'].value;
      const password = signupForm['signup-password'].value;
      const nickname = signupForm['signup-nickname'].value;
      try {
        const cred = await createUserWithEmailAndPassword(auth, email, password);
        userId = cred.user.uid;
        await saveInitialData(userId, email, nickname);
        signupForm.reset();
        // document.getElementById('auth').classList.toggle('hidden');
        loginPopup.style.display = 'none';
        loginFormOpen = false;

      } catch (error) {
        console.error("Error creating user:", error.message);
      }
    });

    logoutLink.addEventListener('click', (event) => {
      event.preventDefault();
      auth.signOut()
        .then(() => {
          userInfo.style.display = 'none';
          loginLink.style.display = 'block';
        })
        .catch((error) => {
          console.error('Error signing out:', error);
        });
    });


    auth.onAuthStateChanged(user => {
      if (user) {
        loadUserData(user.uid);
        userId = user.uid;
        if (score && score > 1000) {


          const gameData = {
            score: score
          };
          saveUserScore(userId, gameId, gameData);
        }



      } else {
        userInfo.style.display = 'none';
        loginContainer.style.display = 'block';

        pauseGame();
      }
    });


    async function loadUserData(userId) {
      try {
        const userDoc = await getDoc(doc(db, 'users', userId));

        if (userDoc.exists()) {
          const userData = userDoc.data();
          userNickname.textContent = userData.nickname;
          userInfo.style.display = 'block';
          loginLink.style.display = 'none';

          const gameAchievements = userData.games?.[gameId]?.achievements || {};
          Object.assign(Achievements, gameAchievements);

          // const gameUpgrades = userData.games?.[gameId]?.megaUpgrades || {};
          // Object.assign(megaUpgrades, gameUpgrades);

          populateAchievements();
          // populateUpgrades();
        } else {
          console.log("No such document!");
        }
      } catch (error) {
        console.error("Error getting user data:", error);
      }
    }


    // document.getElementById('login-toggle').addEventListener('click', function (event) {
    //   event.preventDefault();
    //   document.getElementById('auth').classList.toggle('hidden');
    // });

    // Function to save user score for a specific game
    async function saveUserScore(userId, gameName, gameData) {
      const db = getFirestore();
      const userDocRef = doc(db, 'users', userId);
      const loginTime = new Date();
      const sessionLength = loginTime - gameStartTime;

      if (typeof gameData === 'undefined' || typeof sessionLength === 'undefined') {
        console.error('Invalid game data or session length');
        return;
      }

      const userDoc = await getDoc(userDocRef);
      if (userDoc.exists()) {
        const userData = userDoc.data();
        const existingAchievements = userData.games?.[gameName]?.achievements || {};

        const activeMegaUpgradeNames = activeMegaUpgrades.map(upgrade => upgrade.name);

        const updatedAchievements = { ...existingAchievements, ...Achievements };

        //FirebaseError: Function arrayUnion() called with invalid data. Unsupported field value: undefined (found in document users/fpm9uNmvYeb9HKnZ32juQTmyxzj2)
        // usedUpgrades: activeMegaUpgradeNames

        const fullGameData = {
          [`games.${gameName}.scores`]: arrayUnion({
            score: gameData.score,
            topWeapons: gameData.topWeapons,
            sessionLength: sessionLength,
            loginTime: loginTime,
            gameMode: currentMode
            // Add the game mode to the saved data
          }),
          [`games.${gameName}.achievements`]: updatedAchievements,
        };

        await updateDoc(userDocRef, fullGameData);
      } else {
        const gameData = {
          [`games.${gameName}.scores`]: [
            {
              score: score,
              sessionLength: sessionLength,
              loginTime: loginTime,
              gameMode: currentMode  // Add the game mode to the saved data
            }
          ],
          [`games.${gameName}.achievements`]: Achievements,
        };

        await setDoc(userDocRef, gameData);
      }
    }

    window.saveUserScore = saveUserScore;

    // Function to save initial user data
    async function saveUserData(userId, gameName) {
      const db = getFirestore();
      const userDocRef = doc(db, 'users', userId);
      const userData = {
        [`games.${gameName} `]: {
          scores: [],
          lastLogin: new Date()
        }
      };
      await setDoc(userDocRef, userData, { merge: true });
    }

    window.saveUserData = saveUserData;


    async function loadLeaderboard(gameName, gameMode) {
      const db = getFirestore();
      const usersSnapshot = await getDocs(collection(db, 'users'));
      const scores = [];

      usersSnapshot.forEach(doc => {
        const userData = doc.data();
        const gameScores = userData.games?.[gameName]?.scores || [];
        gameScores.forEach(session => {
          if (session.score && isFinite(session.score) && session.score <= 100000000 && session.gameMode === gameMode) {
            scores.push({
              nickname: userData.nickname || 'Unnamed',
              score: session.score,
              wave: session.wave  // Assuming we also save the wave number
            });
          }
        });
      });

      scores.sort((a, b) => b.score - a.score);

      const limitedScores = [];
      const playerCounts = {};

      scores.forEach(score => {
        if (!playerCounts[score.nickname]) {
          playerCounts[score.nickname] = 0;
        }
        if (playerCounts[score.nickname] < 3) {
          limitedScores.push(score);
          playerCounts[score.nickname]++;
        }
      });

      const topScores = limitedScores.slice(0, 12);

      const leaderboard = document.getElementById('leaderboard');
      leaderboard.innerHTML = `<h2>Leaderboard - ${getGameModeName(gameMode)}</h2>`;
      topScores.forEach((entry, index) => {
        const formattedScore = entry.score.toLocaleString('en-US', {
          maximumFractionDigits: 0
        });
        const scoreDiv = document.createElement('div');
        scoreDiv.innerText = `${index + 1}. ${entry.nickname}: ${formattedScore} points`;
        leaderboard.appendChild(scoreDiv);
      });

      document.getElementById('leaderboard-container').appendChild(leaderboard);
    }

    function getGameModeName(mode) {
      switch (mode) {
        case GameModes.EASY: return "Easy";
        case GameModes.NORMAL: return "Normal";
        case GameModes.HARD: return "Hard";
        case GameModes.HERO: return "Hero";
        case GameModes.METEORSHOWEREASY: return "Meteor Shower Easy";
        case GameModes.METEORSHOWERNORMAL: return "Meteor Shower Normal";
        case GameModes.METEORSHOWERHARD: return "Meteor Shower Hard";
        case GameModes.METEORSHOWERHERO: return "Meteor Shower Hero";
        case GameModes.PLANETEASY: return "Planet Easy";
        case GameModes.PLANETNORMAL: return "Planet Normal";
        case GameModes.PLANETHARD: return "Planet Hard";
        case GameModes.PLANETHERO: return "Planet Hero";
        case GameModes.ENDLESS_SLOW: return "Endless Slow";
        default: return "Unknown Mode";
      }
    }

    window.loadLeaderboard = loadLeaderboard;


    // Function to load achievements from Firebase or localStorage
    async function loadAchievements() {
      const params = new URLSearchParams(window.location.search);
      const userId = params.get('userId');
      const db = getFirestore();
      let loadedAchievements = {};

      if (userId) {
        const userDocRef = doc(db, 'users', userId);
        const userDoc = await getDoc(userDocRef);

        if (userDoc.exists() && userDoc.data().achievements) {
          loadedAchievements = userDoc.data().achievements;
          console.log('loadach');

        } else {
          const savedAchievements = localStorage.getItem('achievements');
          if (savedAchievements) {
            loadedAchievements = JSON.parse(savedAchievements);
          }
        }
      } else {
        const savedAchievements = localStorage.getItem('achievements');
        if (savedAchievements) {
          loadedAchievements = JSON.parse(savedAchievements);
        }
      }
      Object.assign(Achievements, loadedAchievements);

      return Achievements;
    }

    window.loadAchievements = loadAchievements;

  </script>














  <script src="js/audio.js"></script>




































  <!-- <script src="infinite/leaderboard.js"></script> -->
  <script src="js/game.js"></script>
  <script src="js/asteroids.js"></script>
  <script src="js/weapons.js"></script>
  <script src="js/ships.js"></script>
  <script src="js/upgrade-menu.js"></script>
  <script src="js/upgrades-functions.js"></script>
  <script src="js/upgrades-main.js"></script>

  <script src="js/aliens.js"></script>
  <script src="js/gems.js"></script>
  <script src="js/special-effects.js"></script>


  <!-- <div id="auth" class="hidden">
    <h1>Infinite Games</h1>
    <h2>Login</h2>
    <form id="login-form">
      <input type="email" id="email" placeholder="Email" required>
      <input type="password" id="password" placeholder="Password" required>
      <button type="submit">Login</button>
    </form>
  </div> -->













  <!-- #INFINITEGAMES JS START -->
  <!-- <script src="infinite/js/48_leaderboard_20240709215443.js"></script>
  <script src="infinite/js/48_firebase_20240709215443.js"></script> -->
  <!-- #INFINITEGAMES JS END -->
</body>

</html>